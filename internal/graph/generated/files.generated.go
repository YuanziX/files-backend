// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/model"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

type FolderResolver interface {
	ID(ctx context.Context, obj *postgres.Folder) (string, error)

	CreatedAt(ctx context.Context, obj *postgres.Folder) (*time.Time, error)
	ParentID(ctx context.Context, obj *postgres.Folder) (*string, error)

	ChildrenFolders(ctx context.Context, obj *postgres.Folder) ([]*postgres.Folder, error)
	ChildrenFiles(ctx context.Context, obj *postgres.Folder) ([]*model.File, error)
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _ConfirmUploadsResponse_files(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmUploadsResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConfirmUploadsResponse_files,
		func(ctx context.Context) (any, error) {
			return obj.Files, nil
		},
		nil,
		ec.marshalNFile2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConfirmUploadsResponse_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfirmUploadsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "mimeType":
				return ec.fieldContext_File_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_File_size(ctx, field)
			case "uploadDate":
				return ec.fieldContext_File_uploadDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ConfirmUploadsResponse_failedUploads(ctx context.Context, field graphql.CollectedField, obj *model.ConfirmUploadsResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_ConfirmUploadsResponse_failedUploads,
		func(ctx context.Context) (any, error) {
			return obj.FailedUploads, nil
		},
		nil,
		ec.marshalNFailedUpload2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFailedUploadᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_ConfirmUploadsResponse_failedUploads(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ConfirmUploadsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hash":
				return ec.fieldContext_FailedUpload_hash(ctx, field)
			case "reason":
				return ec.fieldContext_FailedUpload_reason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FailedUpload", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadURL_downloadURL(ctx context.Context, field graphql.CollectedField, obj *model.DownloadURL) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DownloadURL_downloadURL,
		func(ctx context.Context) (any, error) {
			return obj.DownloadURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DownloadURL_downloadURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DownloadURL_filename(ctx context.Context, field graphql.CollectedField, obj *model.DownloadURL) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_DownloadURL_filename,
		func(ctx context.Context) (any, error) {
			return obj.Filename, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_DownloadURL_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DownloadURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedUpload_hash(ctx context.Context, field graphql.CollectedField, obj *model.FailedUpload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedUpload_hash,
		func(ctx context.Context) (any, error) {
			return obj.Hash, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedUpload_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedUpload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailedUpload_reason(ctx context.Context, field graphql.CollectedField, obj *model.FailedUpload) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_FailedUpload_reason,
		func(ctx context.Context) (any, error) {
			return obj.Reason, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_FailedUpload_reason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailedUpload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_id(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_id,
		func(ctx context.Context) (any, error) {
			return obj.ID, nil
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_filename(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_filename,
		func(ctx context.Context) (any, error) {
			return obj.Filename, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_mimeType(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_mimeType,
		func(ctx context.Context) (any, error) {
			return obj.MimeType, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_mimeType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_size(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_size,
		func(ctx context.Context) (any, error) {
			return obj.Size, nil
		},
		nil,
		ec.marshalNInt2int32,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_uploadDate(ctx context.Context, field graphql.CollectedField, obj *model.File) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_File_uploadDate,
		func(ctx context.Context) (any, error) {
			return obj.UploadDate, nil
		},
		nil,
		ec.marshalNTime2timeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_File_uploadDate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_id(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_id,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Folder().ID(ctx, obj)
		},
		nil,
		ec.marshalNID2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_name(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_name,
		func(ctx context.Context) (any, error) {
			return obj.Name, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_createdAt(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_createdAt,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Folder().CreatedAt(ctx, obj)
		},
		nil,
		ec.marshalNTime2ᚖtimeᚐTime,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_createdAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_parentID(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_parentID,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Folder().ParentID(ctx, obj)
		},
		nil,
		ec.marshalOID2ᚖstring,
		true,
		false,
	)
}

func (ec *executionContext) fieldContext_Folder_parentID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_path(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_path,
		func(ctx context.Context) (any, error) {
			return obj.Path, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_realPath(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_realPath,
		func(ctx context.Context) (any, error) {
			return obj.RealPath, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_realPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_childrenFolders(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_childrenFolders,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Folder().ChildrenFolders(ctx, obj)
		},
		nil,
		ec.marshalNFolder2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolderᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_childrenFolders(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Folder_id(ctx, field)
			case "name":
				return ec.fieldContext_Folder_name(ctx, field)
			case "createdAt":
				return ec.fieldContext_Folder_createdAt(ctx, field)
			case "parentID":
				return ec.fieldContext_Folder_parentID(ctx, field)
			case "path":
				return ec.fieldContext_Folder_path(ctx, field)
			case "realPath":
				return ec.fieldContext_Folder_realPath(ctx, field)
			case "childrenFolders":
				return ec.fieldContext_Folder_childrenFolders(ctx, field)
			case "childrenFiles":
				return ec.fieldContext_Folder_childrenFiles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Folder", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Folder_childrenFiles(ctx context.Context, field graphql.CollectedField, obj *postgres.Folder) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_Folder_childrenFiles,
		func(ctx context.Context) (any, error) {
			return ec.resolvers.Folder().ChildrenFiles(ctx, obj)
		},
		nil,
		ec.marshalNFile2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_Folder_childrenFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Folder",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "mimeType":
				return ec.fieldContext_File_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_File_size(ctx, field)
			case "uploadDate":
				return ec.fieldContext_File_uploadDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreSignedURL_filename(ctx context.Context, field graphql.CollectedField, obj *model.PreSignedURL) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreSignedURL_filename,
		func(ctx context.Context) (any, error) {
			return obj.Filename, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreSignedURL_filename(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreSignedURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreSignedURL_hash(ctx context.Context, field graphql.CollectedField, obj *model.PreSignedURL) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreSignedURL_hash,
		func(ctx context.Context) (any, error) {
			return obj.Hash, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreSignedURL_hash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreSignedURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreSignedURL_uploadURL(ctx context.Context, field graphql.CollectedField, obj *model.PreSignedURL) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreSignedURL_uploadURL,
		func(ctx context.Context) (any, error) {
			return obj.UploadURL, nil
		},
		nil,
		ec.marshalNString2string,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreSignedURL_uploadURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreSignedURL",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreUploadCheckResponse_completedFiles(ctx context.Context, field graphql.CollectedField, obj *model.PreUploadCheckResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreUploadCheckResponse_completedFiles,
		func(ctx context.Context) (any, error) {
			return obj.CompletedFiles, nil
		},
		nil,
		ec.marshalNFile2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreUploadCheckResponse_completedFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreUploadCheckResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_File_id(ctx, field)
			case "filename":
				return ec.fieldContext_File_filename(ctx, field)
			case "mimeType":
				return ec.fieldContext_File_mimeType(ctx, field)
			case "size":
				return ec.fieldContext_File_size(ctx, field)
			case "uploadDate":
				return ec.fieldContext_File_uploadDate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreUploadCheckResponse_newFiles(ctx context.Context, field graphql.CollectedField, obj *model.PreUploadCheckResponse) (ret graphql.Marshaler) {
	return graphql.ResolveField(
		ctx,
		ec.OperationContext,
		field,
		ec.fieldContext_PreUploadCheckResponse_newFiles,
		func(ctx context.Context) (any, error) {
			return obj.NewFiles, nil
		},
		nil,
		ec.marshalNPreSignedURL2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreSignedURLᚄ,
		true,
		true,
	)
}

func (ec *executionContext) fieldContext_PreUploadCheckResponse_newFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreUploadCheckResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filename":
				return ec.fieldContext_PreSignedURL_filename(ctx, field)
			case "hash":
				return ec.fieldContext_PreSignedURL_hash(ctx, field)
			case "uploadURL":
				return ec.fieldContext_PreSignedURL_uploadURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreSignedURL", field.Name)
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputConfirmUploadInput(ctx context.Context, obj any) (model.ConfirmUploadInput, error) {
	var it model.ConfirmUploadInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"filename", "hash", "size", "mimeType", "folderId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "filename":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filename"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filename = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int32(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "mimeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mimeType"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.MimeType = data
		case "folderId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("folderId"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FolderID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileFilterInput(ctx context.Context, obj any) (model.FileFilterInput, error) {
	var it model.FileFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"filename", "mimeType", "minSize", "maxSize", "uploadedAfter", "uploadedBefore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "filename":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filename"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filename = data
		case "mimeType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mimeType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MimeType = data
		case "minSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minSize"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinSize = data
		case "maxSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxSize"))
			data, err := ec.unmarshalOInt2ᚖint32(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSize = data
		case "uploadedAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uploadedAfter"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UploadedAfter = data
		case "uploadedBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uploadedBefore"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UploadedBefore = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFileSortInput(ctx context.Context, obj any) (model.FileSortInput, error) {
	var it model.FileSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "order"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNFileSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileSortField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalNSortOrder2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐSortOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFolderFilterInput(ctx context.Context, obj any) (model.FolderFilterInput, error) {
	var it model.FolderFilterInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "createdAfter", "createdBefore"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "createdAfter":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAfter"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAfter = data
		case "createdBefore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdBefore"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedBefore = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFolderSortInput(ctx context.Context, obj any) (model.FolderSortInput, error) {
	var it model.FolderSortInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"field", "order"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNFolderSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFolderSortField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalNSortOrder2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐSortOrder(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreUploadFileInput(ctx context.Context, obj any) (model.PreUploadFileInput, error) {
	var it model.PreUploadFileInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"filename", "folderId", "hash"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "filename":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filename"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Filename = data
		case "folderId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("folderId"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FolderID = data
		case "hash":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hash"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hash = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var confirmUploadsResponseImplementors = []string{"ConfirmUploadsResponse"}

func (ec *executionContext) _ConfirmUploadsResponse(ctx context.Context, sel ast.SelectionSet, obj *model.ConfirmUploadsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, confirmUploadsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ConfirmUploadsResponse")
		case "files":
			out.Values[i] = ec._ConfirmUploadsResponse_files(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failedUploads":
			out.Values[i] = ec._ConfirmUploadsResponse_failedUploads(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var downloadURLImplementors = []string{"DownloadURL"}

func (ec *executionContext) _DownloadURL(ctx context.Context, sel ast.SelectionSet, obj *model.DownloadURL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, downloadURLImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DownloadURL")
		case "downloadURL":
			out.Values[i] = ec._DownloadURL_downloadURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filename":
			out.Values[i] = ec._DownloadURL_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failedUploadImplementors = []string{"FailedUpload"}

func (ec *executionContext) _FailedUpload(ctx context.Context, sel ast.SelectionSet, obj *model.FailedUpload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failedUploadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailedUpload")
		case "hash":
			out.Values[i] = ec._FailedUpload_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reason":
			out.Values[i] = ec._FailedUpload_reason(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.File) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "id":
			out.Values[i] = ec._File_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filename":
			out.Values[i] = ec._File_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mimeType":
			out.Values[i] = ec._File_mimeType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "size":
			out.Values[i] = ec._File_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadDate":
			out.Values[i] = ec._File_uploadDate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var folderImplementors = []string{"Folder"}

func (ec *executionContext) _Folder(ctx context.Context, sel ast.SelectionSet, obj *postgres.Folder) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, folderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Folder")
		case "id":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Folder_id(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "name":
			out.Values[i] = ec._Folder_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdAt":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Folder_createdAt(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "parentID":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Folder_parentID(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "path":
			out.Values[i] = ec._Folder_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "realPath":
			out.Values[i] = ec._Folder_realPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "childrenFolders":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Folder_childrenFolders(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childrenFiles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Folder_childrenFiles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preSignedURLImplementors = []string{"PreSignedURL"}

func (ec *executionContext) _PreSignedURL(ctx context.Context, sel ast.SelectionSet, obj *model.PreSignedURL) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preSignedURLImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreSignedURL")
		case "filename":
			out.Values[i] = ec._PreSignedURL_filename(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hash":
			out.Values[i] = ec._PreSignedURL_hash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "uploadURL":
			out.Values[i] = ec._PreSignedURL_uploadURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preUploadCheckResponseImplementors = []string{"PreUploadCheckResponse"}

func (ec *executionContext) _PreUploadCheckResponse(ctx context.Context, sel ast.SelectionSet, obj *model.PreUploadCheckResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preUploadCheckResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreUploadCheckResponse")
		case "completedFiles":
			out.Values[i] = ec._PreUploadCheckResponse_completedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newFiles":
			out.Values[i] = ec._PreUploadCheckResponse_newFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNConfirmUploadInput2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐConfirmUploadInputᚄ(ctx context.Context, v any) ([]*model.ConfirmUploadInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.ConfirmUploadInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNConfirmUploadInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐConfirmUploadInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNConfirmUploadInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐConfirmUploadInput(ctx context.Context, v any) (*model.ConfirmUploadInput, error) {
	res, err := ec.unmarshalInputConfirmUploadInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNConfirmUploadsResponse2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐConfirmUploadsResponse(ctx context.Context, sel ast.SelectionSet, v model.ConfirmUploadsResponse) graphql.Marshaler {
	return ec._ConfirmUploadsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNConfirmUploadsResponse2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐConfirmUploadsResponse(ctx context.Context, sel ast.SelectionSet, v *model.ConfirmUploadsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ConfirmUploadsResponse(ctx, sel, v)
}

func (ec *executionContext) marshalNDownloadURL2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐDownloadURL(ctx context.Context, sel ast.SelectionSet, v model.DownloadURL) graphql.Marshaler {
	return ec._DownloadURL(ctx, sel, &v)
}

func (ec *executionContext) marshalNDownloadURL2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐDownloadURL(ctx context.Context, sel ast.SelectionSet, v *model.DownloadURL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DownloadURL(ctx, sel, v)
}

func (ec *executionContext) marshalNFailedUpload2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFailedUploadᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.FailedUpload) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFailedUpload2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFailedUpload(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFailedUpload2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFailedUpload(ctx context.Context, sel ast.SelectionSet, v *model.FailedUpload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._FailedUpload(ctx, sel, v)
}

func (ec *executionContext) marshalNFile2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.File) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFile2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFile(ctx context.Context, sel ast.SelectionSet, v *model.File) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFileSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileSortField(ctx context.Context, v any) (model.FileSortField, error) {
	var res model.FileSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFileSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileSortField(ctx context.Context, sel ast.SelectionSet, v model.FileSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNFolder2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolder(ctx context.Context, sel ast.SelectionSet, v postgres.Folder) graphql.Marshaler {
	return ec._Folder(ctx, sel, &v)
}

func (ec *executionContext) marshalNFolder2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolderᚄ(ctx context.Context, sel ast.SelectionSet, v []*postgres.Folder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFolder2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFolder2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolder(ctx context.Context, sel ast.SelectionSet, v *postgres.Folder) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Folder(ctx, sel, v)
}

func (ec *executionContext) unmarshalNFolderSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFolderSortField(ctx context.Context, v any) (model.FolderSortField, error) {
	var res model.FolderSortField
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFolderSortField2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFolderSortField(ctx context.Context, sel ast.SelectionSet, v model.FolderSortField) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPreSignedURL2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreSignedURLᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PreSignedURL) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreSignedURL2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreSignedURL(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPreSignedURL2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreSignedURL(ctx context.Context, sel ast.SelectionSet, v *model.PreSignedURL) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PreSignedURL(ctx, sel, v)
}

func (ec *executionContext) marshalNPreUploadCheckResponse2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreUploadCheckResponse(ctx context.Context, sel ast.SelectionSet, v model.PreUploadCheckResponse) graphql.Marshaler {
	return ec._PreUploadCheckResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreUploadCheckResponse2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreUploadCheckResponse(ctx context.Context, sel ast.SelectionSet, v *model.PreUploadCheckResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PreUploadCheckResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPreUploadFileInput2ᚕᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreUploadFileInputᚄ(ctx context.Context, v any) ([]*model.PreUploadFileInput, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.PreUploadFileInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPreUploadFileInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreUploadFileInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPreUploadFileInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐPreUploadFileInput(ctx context.Context, v any) (*model.PreUploadFileInput, error) {
	res, err := ec.unmarshalInputPreUploadFileInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSortOrder2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐSortOrder(ctx context.Context, v any) (model.SortOrder, error) {
	var res model.SortOrder
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortOrder2githubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐSortOrder(ctx context.Context, sel ast.SelectionSet, v model.SortOrder) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOFile2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFile(ctx context.Context, sel ast.SelectionSet, v *model.File) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFileFilterInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileFilterInput(ctx context.Context, v any) (*model.FileFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFileSortInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFileSortInput(ctx context.Context, v any) (*model.FileSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFileSortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFolder2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋdatabaseᚋpostgresᚐFolder(ctx context.Context, sel ast.SelectionSet, v *postgres.Folder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Folder(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFolderFilterInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFolderFilterInput(ctx context.Context, v any) (*model.FolderFilterInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFolderFilterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFolderSortInput2ᚖgithubᚗcomᚋYuanziXᚋfilesᚑbackendᚋinternalᚋgraphᚋmodelᚐFolderSortInput(ctx context.Context, v any) (*model.FolderSortInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFolderSortInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

// endregion ***************************** type.gotpl *****************************
