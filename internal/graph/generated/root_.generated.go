// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/YuanziX/files-backend/internal/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Folder() FolderResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Share() ShareResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	HasRole func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	AdminFile struct {
		DownloadCount func(childComplexity int) int
		Filename      func(childComplexity int) int
		ID            func(childComplexity int) int
		MimeType      func(childComplexity int) int
		OwnerID       func(childComplexity int) int
		Size          func(childComplexity int) int
		UploadDate    func(childComplexity int) int
	}

	AuthResponse struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	ConfirmUploadsResponse struct {
		FailedUploads func(childComplexity int) int
		Files         func(childComplexity int) int
	}

	DownloadFileResponse struct {
		Filename func(childComplexity int) int
		URL      func(childComplexity int) int
	}

	DownloadURL struct {
		DownloadURL func(childComplexity int) int
		Filename    func(childComplexity int) int
	}

	FailedUpload struct {
		Hash   func(childComplexity int) int
		Reason func(childComplexity int) int
	}

	File struct {
		Filename   func(childComplexity int) int
		ID         func(childComplexity int) int
		MimeType   func(childComplexity int) int
		Size       func(childComplexity int) int
		UploadDate func(childComplexity int) int
	}

	Folder struct {
		ChildrenFiles   func(childComplexity int) int
		ChildrenFolders func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		ParentID        func(childComplexity int) int
		Path            func(childComplexity int) int
		RealPath        func(childComplexity int) int
	}

	GetFilesResponse struct {
		Files      func(childComplexity int) int
		Pagination func(childComplexity int) int
	}

	Mutation struct {
		ConfirmUploads        func(childComplexity int, uploads []*model.ConfirmUploadInput) int
		CreateAdminUser       func(childComplexity int, email string, password string) int
		CreateFolder          func(childComplexity int, name string, parentID *string) int
		DeleteFile            func(childComplexity int, fileID string) int
		DeleteFolder          func(childComplexity int, folderID string) int
		GetDownloadURL        func(childComplexity int, fileID string, publicToken *string) int
		Login                 func(childComplexity int, input model.LoginUser) int
		PreUploadCheck        func(childComplexity int, files []*model.PreUploadFileInput) int
		RegisterUser          func(childComplexity int, input model.RegisterUser) int
		RevokePubliclyShared  func(childComplexity int, publicToken string) int
		ShareFilePublic       func(childComplexity int, fileID string) int
		ShareFileWithUser     func(childComplexity int, fileID string, email string) int
		ShareFolderPublic     func(childComplexity int, folderID string) int
		ShareFolderWithUser   func(childComplexity int, folderID string, email string) int
		UnshareFileWithUser   func(childComplexity int, fileID string, email string) int
		UnshareFolderWithUser func(childComplexity int, folderID string, email string) int
	}

	Pagination struct {
		Count      func(childComplexity int) int
		Limit      func(childComplexity int) int
		PageNo     func(childComplexity int) int
		TotalCount func(childComplexity int) int
		TotalPages func(childComplexity int) int
	}

	PreSignedURL struct {
		Filename  func(childComplexity int) int
		Hash      func(childComplexity int) int
		UploadURL func(childComplexity int) int
	}

	PreUploadCheckResponse struct {
		CompletedFiles func(childComplexity int) int
		NewFiles       func(childComplexity int) int
	}

	Query struct {
		DownloadFile       func(childComplexity int, fileID string) int
		GetFile            func(childComplexity int, fileID string, publicToken *string) int
		GetFileShares      func(childComplexity int, fileID string) int
		GetFiles           func(childComplexity int, limit *int32, pageNo *int32) int
		GetFilesInFolder   func(childComplexity int, folderID *string, publicToken *string, sort *model.FileSortInput, filter *model.FileFilterInput) int
		GetFolderDetails   func(childComplexity int, folderID *string, publicToken *string) int
		GetFolderShares    func(childComplexity int, folderID string) int
		GetFoldersInFolder func(childComplexity int, folderID *string, publicToken *string, sort *model.FolderSortInput, filter *model.FolderFilterInput) int
		GetMyShares        func(childComplexity int) int
		GetUserByID        func(childComplexity int, userID string) int
		Me                 func(childComplexity int) int
		SearchFiles        func(childComplexity int, query string, search string) int
	}

	Share struct {
		CreatedAt     func(childComplexity int) int
		DownloadCount func(childComplexity int) int
		ID            func(childComplexity int) int
		Owner         func(childComplexity int) int
		PublicToken   func(childComplexity int) int
		ShareType     func(childComplexity int) int
		SharedWith    func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Role      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AdminFile.downloadCount":
		if e.complexity.AdminFile.DownloadCount == nil {
			break
		}

		return e.complexity.AdminFile.DownloadCount(childComplexity), true

	case "AdminFile.filename":
		if e.complexity.AdminFile.Filename == nil {
			break
		}

		return e.complexity.AdminFile.Filename(childComplexity), true

	case "AdminFile.id":
		if e.complexity.AdminFile.ID == nil {
			break
		}

		return e.complexity.AdminFile.ID(childComplexity), true

	case "AdminFile.mimeType":
		if e.complexity.AdminFile.MimeType == nil {
			break
		}

		return e.complexity.AdminFile.MimeType(childComplexity), true

	case "AdminFile.ownerID":
		if e.complexity.AdminFile.OwnerID == nil {
			break
		}

		return e.complexity.AdminFile.OwnerID(childComplexity), true

	case "AdminFile.size":
		if e.complexity.AdminFile.Size == nil {
			break
		}

		return e.complexity.AdminFile.Size(childComplexity), true

	case "AdminFile.uploadDate":
		if e.complexity.AdminFile.UploadDate == nil {
			break
		}

		return e.complexity.AdminFile.UploadDate(childComplexity), true

	case "AuthResponse.token":
		if e.complexity.AuthResponse.Token == nil {
			break
		}

		return e.complexity.AuthResponse.Token(childComplexity), true

	case "AuthResponse.user":
		if e.complexity.AuthResponse.User == nil {
			break
		}

		return e.complexity.AuthResponse.User(childComplexity), true

	case "ConfirmUploadsResponse.failedUploads":
		if e.complexity.ConfirmUploadsResponse.FailedUploads == nil {
			break
		}

		return e.complexity.ConfirmUploadsResponse.FailedUploads(childComplexity), true

	case "ConfirmUploadsResponse.files":
		if e.complexity.ConfirmUploadsResponse.Files == nil {
			break
		}

		return e.complexity.ConfirmUploadsResponse.Files(childComplexity), true

	case "DownloadFileResponse.filename":
		if e.complexity.DownloadFileResponse.Filename == nil {
			break
		}

		return e.complexity.DownloadFileResponse.Filename(childComplexity), true

	case "DownloadFileResponse.url":
		if e.complexity.DownloadFileResponse.URL == nil {
			break
		}

		return e.complexity.DownloadFileResponse.URL(childComplexity), true

	case "DownloadURL.downloadURL":
		if e.complexity.DownloadURL.DownloadURL == nil {
			break
		}

		return e.complexity.DownloadURL.DownloadURL(childComplexity), true

	case "DownloadURL.filename":
		if e.complexity.DownloadURL.Filename == nil {
			break
		}

		return e.complexity.DownloadURL.Filename(childComplexity), true

	case "FailedUpload.hash":
		if e.complexity.FailedUpload.Hash == nil {
			break
		}

		return e.complexity.FailedUpload.Hash(childComplexity), true

	case "FailedUpload.reason":
		if e.complexity.FailedUpload.Reason == nil {
			break
		}

		return e.complexity.FailedUpload.Reason(childComplexity), true

	case "File.filename":
		if e.complexity.File.Filename == nil {
			break
		}

		return e.complexity.File.Filename(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.uploadDate":
		if e.complexity.File.UploadDate == nil {
			break
		}

		return e.complexity.File.UploadDate(childComplexity), true

	case "Folder.childrenFiles":
		if e.complexity.Folder.ChildrenFiles == nil {
			break
		}

		return e.complexity.Folder.ChildrenFiles(childComplexity), true

	case "Folder.childrenFolders":
		if e.complexity.Folder.ChildrenFolders == nil {
			break
		}

		return e.complexity.Folder.ChildrenFolders(childComplexity), true

	case "Folder.createdAt":
		if e.complexity.Folder.CreatedAt == nil {
			break
		}

		return e.complexity.Folder.CreatedAt(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.name":
		if e.complexity.Folder.Name == nil {
			break
		}

		return e.complexity.Folder.Name(childComplexity), true

	case "Folder.parentID":
		if e.complexity.Folder.ParentID == nil {
			break
		}

		return e.complexity.Folder.ParentID(childComplexity), true

	case "Folder.path":
		if e.complexity.Folder.Path == nil {
			break
		}

		return e.complexity.Folder.Path(childComplexity), true

	case "Folder.realPath":
		if e.complexity.Folder.RealPath == nil {
			break
		}

		return e.complexity.Folder.RealPath(childComplexity), true

	case "GetFilesResponse.files":
		if e.complexity.GetFilesResponse.Files == nil {
			break
		}

		return e.complexity.GetFilesResponse.Files(childComplexity), true

	case "GetFilesResponse.pagination":
		if e.complexity.GetFilesResponse.Pagination == nil {
			break
		}

		return e.complexity.GetFilesResponse.Pagination(childComplexity), true

	case "Mutation.confirmUploads":
		if e.complexity.Mutation.ConfirmUploads == nil {
			break
		}

		args, err := ec.field_Mutation_confirmUploads_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmUploads(childComplexity, args["uploads"].([]*model.ConfirmUploadInput)), true

	case "Mutation.createAdminUser":
		if e.complexity.Mutation.CreateAdminUser == nil {
			break
		}

		args, err := ec.field_Mutation_createAdminUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateAdminUser(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Mutation.createFolder":
		if e.complexity.Mutation.CreateFolder == nil {
			break
		}

		args, err := ec.field_Mutation_createFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFolder(childComplexity, args["name"].(string), args["parentId"].(*string)), true

	case "Mutation.deleteFile":
		if e.complexity.Mutation.DeleteFile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFile(childComplexity, args["fileId"].(string)), true

	case "Mutation.deleteFolder":
		if e.complexity.Mutation.DeleteFolder == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFolder(childComplexity, args["folderId"].(string)), true

	case "Mutation.getDownloadURL":
		if e.complexity.Mutation.GetDownloadURL == nil {
			break
		}

		args, err := ec.field_Mutation_getDownloadURL_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.GetDownloadURL(childComplexity, args["fileId"].(string), args["publicToken"].(*string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginUser)), true

	case "Mutation.preUploadCheck":
		if e.complexity.Mutation.PreUploadCheck == nil {
			break
		}

		args, err := ec.field_Mutation_preUploadCheck_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PreUploadCheck(childComplexity, args["files"].([]*model.PreUploadFileInput)), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(model.RegisterUser)), true

	case "Mutation.revokePubliclyShared":
		if e.complexity.Mutation.RevokePubliclyShared == nil {
			break
		}

		args, err := ec.field_Mutation_revokePubliclyShared_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RevokePubliclyShared(childComplexity, args["publicToken"].(string)), true

	case "Mutation.shareFilePublic":
		if e.complexity.Mutation.ShareFilePublic == nil {
			break
		}

		args, err := ec.field_Mutation_shareFilePublic_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ShareFilePublic(childComplexity, args["fileId"].(string)), true

	case "Mutation.shareFileWithUser":
		if e.complexity.Mutation.ShareFileWithUser == nil {
			break
		}

		args, err := ec.field_Mutation_shareFileWithUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ShareFileWithUser(childComplexity, args["fileId"].(string), args["email"].(string)), true

	case "Mutation.shareFolderPublic":
		if e.complexity.Mutation.ShareFolderPublic == nil {
			break
		}

		args, err := ec.field_Mutation_shareFolderPublic_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ShareFolderPublic(childComplexity, args["folderId"].(string)), true

	case "Mutation.shareFolderWithUser":
		if e.complexity.Mutation.ShareFolderWithUser == nil {
			break
		}

		args, err := ec.field_Mutation_shareFolderWithUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ShareFolderWithUser(childComplexity, args["folderId"].(string), args["email"].(string)), true

	case "Mutation.unshareFileWithUser":
		if e.complexity.Mutation.UnshareFileWithUser == nil {
			break
		}

		args, err := ec.field_Mutation_unshareFileWithUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnshareFileWithUser(childComplexity, args["fileId"].(string), args["email"].(string)), true

	case "Mutation.unshareFolderWithUser":
		if e.complexity.Mutation.UnshareFolderWithUser == nil {
			break
		}

		args, err := ec.field_Mutation_unshareFolderWithUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnshareFolderWithUser(childComplexity, args["folderId"].(string), args["email"].(string)), true

	case "Pagination.count":
		if e.complexity.Pagination.Count == nil {
			break
		}

		return e.complexity.Pagination.Count(childComplexity), true

	case "Pagination.limit":
		if e.complexity.Pagination.Limit == nil {
			break
		}

		return e.complexity.Pagination.Limit(childComplexity), true

	case "Pagination.pageNo":
		if e.complexity.Pagination.PageNo == nil {
			break
		}

		return e.complexity.Pagination.PageNo(childComplexity), true

	case "Pagination.totalCount":
		if e.complexity.Pagination.TotalCount == nil {
			break
		}

		return e.complexity.Pagination.TotalCount(childComplexity), true

	case "Pagination.totalPages":
		if e.complexity.Pagination.TotalPages == nil {
			break
		}

		return e.complexity.Pagination.TotalPages(childComplexity), true

	case "PreSignedURL.filename":
		if e.complexity.PreSignedURL.Filename == nil {
			break
		}

		return e.complexity.PreSignedURL.Filename(childComplexity), true

	case "PreSignedURL.hash":
		if e.complexity.PreSignedURL.Hash == nil {
			break
		}

		return e.complexity.PreSignedURL.Hash(childComplexity), true

	case "PreSignedURL.uploadURL":
		if e.complexity.PreSignedURL.UploadURL == nil {
			break
		}

		return e.complexity.PreSignedURL.UploadURL(childComplexity), true

	case "PreUploadCheckResponse.completedFiles":
		if e.complexity.PreUploadCheckResponse.CompletedFiles == nil {
			break
		}

		return e.complexity.PreUploadCheckResponse.CompletedFiles(childComplexity), true

	case "PreUploadCheckResponse.newFiles":
		if e.complexity.PreUploadCheckResponse.NewFiles == nil {
			break
		}

		return e.complexity.PreUploadCheckResponse.NewFiles(childComplexity), true

	case "Query.downloadFile":
		if e.complexity.Query.DownloadFile == nil {
			break
		}

		args, err := ec.field_Query_downloadFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DownloadFile(childComplexity, args["fileID"].(string)), true

	case "Query.getFile":
		if e.complexity.Query.GetFile == nil {
			break
		}

		args, err := ec.field_Query_getFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFile(childComplexity, args["fileId"].(string), args["publicToken"].(*string)), true

	case "Query.getFileShares":
		if e.complexity.Query.GetFileShares == nil {
			break
		}

		args, err := ec.field_Query_getFileShares_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFileShares(childComplexity, args["fileId"].(string)), true

	case "Query.getFiles":
		if e.complexity.Query.GetFiles == nil {
			break
		}

		args, err := ec.field_Query_getFiles_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFiles(childComplexity, args["limit"].(*int32), args["pageNo"].(*int32)), true

	case "Query.getFilesInFolder":
		if e.complexity.Query.GetFilesInFolder == nil {
			break
		}

		args, err := ec.field_Query_getFilesInFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFilesInFolder(childComplexity, args["folderId"].(*string), args["publicToken"].(*string), args["sort"].(*model.FileSortInput), args["filter"].(*model.FileFilterInput)), true

	case "Query.getFolderDetails":
		if e.complexity.Query.GetFolderDetails == nil {
			break
		}

		args, err := ec.field_Query_getFolderDetails_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFolderDetails(childComplexity, args["folderId"].(*string), args["publicToken"].(*string)), true

	case "Query.getFolderShares":
		if e.complexity.Query.GetFolderShares == nil {
			break
		}

		args, err := ec.field_Query_getFolderShares_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFolderShares(childComplexity, args["folderId"].(string)), true

	case "Query.getFoldersInFolder":
		if e.complexity.Query.GetFoldersInFolder == nil {
			break
		}

		args, err := ec.field_Query_getFoldersInFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetFoldersInFolder(childComplexity, args["folderId"].(*string), args["publicToken"].(*string), args["sort"].(*model.FolderSortInput), args["filter"].(*model.FolderFilterInput)), true

	case "Query.getMyShares":
		if e.complexity.Query.GetMyShares == nil {
			break
		}

		return e.complexity.Query.GetMyShares(childComplexity), true

	case "Query.getUserByID":
		if e.complexity.Query.GetUserByID == nil {
			break
		}

		args, err := ec.field_Query_getUserByID_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetUserByID(childComplexity, args["userID"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.searchFiles":
		if e.complexity.Query.SearchFiles == nil {
			break
		}

		args, err := ec.field_Query_searchFiles_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.SearchFiles(childComplexity, args["query"].(string), args["search"].(string)), true

	case "Share.createdAt":
		if e.complexity.Share.CreatedAt == nil {
			break
		}

		return e.complexity.Share.CreatedAt(childComplexity), true

	case "Share.downloadCount":
		if e.complexity.Share.DownloadCount == nil {
			break
		}

		return e.complexity.Share.DownloadCount(childComplexity), true

	case "Share.id":
		if e.complexity.Share.ID == nil {
			break
		}

		return e.complexity.Share.ID(childComplexity), true

	case "Share.owner":
		if e.complexity.Share.Owner == nil {
			break
		}

		return e.complexity.Share.Owner(childComplexity), true

	case "Share.publicToken":
		if e.complexity.Share.PublicToken == nil {
			break
		}

		return e.complexity.Share.PublicToken(childComplexity), true

	case "Share.shareType":
		if e.complexity.Share.ShareType == nil {
			break
		}

		return e.complexity.Share.ShareType(childComplexity), true

	case "Share.sharedWith":
		if e.complexity.Share.SharedWith == nil {
			break
		}

		return e.complexity.Share.SharedWith(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputConfirmUploadInput,
		ec.unmarshalInputFileFilterInput,
		ec.unmarshalInputFileSortInput,
		ec.unmarshalInputFolderFilterInput,
		ec.unmarshalInputFolderSortInput,
		ec.unmarshalInputLoginUser,
		ec.unmarshalInputPreUploadFileInput,
		ec.unmarshalInputRegisterUser,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/admin.graphqls", Input: `type AdminFile {
  id: ID!
  ownerID: ID!
  filename: String!
  mimeType: String!
  size: Int!
  uploadDate: Time!
  downloadCount: Int!
}

type Pagination {
  count: Int!
  totalCount: Int!
  pageNo: Int!
  totalPages: Int!
  limit: Int!
}

type GetFilesResponse {
  files: [AdminFile!]!
  pagination: Pagination!
}

type DownloadFileResponse {
  url: String!
  filename: String!
}

extend type Mutation {
  createAdminUser(email: String!, password: String!): String!
}

extend type Query {
  getFiles(limit: Int, pageNo: Int): GetFilesResponse! @hasRole(role: "admin")
  downloadFile(fileID: ID!): DownloadFileResponse! @hasRole(role: "admin")
  getUserByID(userID: ID!): User! @hasRole(role: "admin")
}
`, BuiltIn: false},
	{Name: "../schema/directives.graphqls", Input: `directive @auth on FIELD_DEFINITION

directive @hasRole(role: Role!) on FIELD_DEFINITION

enum Role {
  admin
  user
}
`, BuiltIn: false},
	{Name: "../schema/files.graphqls", Input: `scalar Time

type File {
  id: ID!
  filename: String!
  mimeType: String!
  size: Int!
  uploadDate: Time!
}

type Folder {
  id: ID!
  name: String!
  createdAt: Time!
  parentID: ID
  path: String!
  realPath: String!
  childrenFolders: [Folder!]!
  childrenFiles: [File!]!
}

type PreSignedURL {
  filename: String!
  hash: String!
  uploadURL: String!
}

type PreUploadCheckResponse {
  completedFiles: [File!]!
  newFiles: [PreSignedURL!]!
}

type DownloadURL {
  downloadURL: String!
  filename: String!
}

input PreUploadFileInput {
  filename: String!
  folderId: ID
  hash: String!
}

input ConfirmUploadInput {
  filename: String!
  hash: String!
  size: Int!
  mimeType: String!
  folderId: ID
}

type FailedUpload {
  hash: String!
  reason: String!
}

type ConfirmUploadsResponse {
  files: [File!]!
  failedUploads: [FailedUpload!]!
}

enum SortOrder {
  ASC
  DESC
}

enum FileSortField {
  FILENAME
  SIZE
  UPLOAD_DATE
  MIME_TYPE
}

enum FolderSortField {
  NAME
  CREATED_AT
}

input FileSortInput {
  field: FileSortField!
  order: SortOrder!
}

input FolderSortInput {
  field: FolderSortField!
  order: SortOrder!
}

input FileFilterInput {
  filename: String
  mimeType: String
  minSize: Int
  maxSize: Int
  uploadedAfter: Time
  uploadedBefore: Time
}

input FolderFilterInput {
  name: String
  createdAfter: Time
  createdBefore: Time
}

extend type Query {
  getFile(fileId: ID!, publicToken: String): File
  getFilesInFolder(
    folderId: ID
    publicToken: String
    sort: FileSortInput
    filter: FileFilterInput
  ): [File!]!
  getFoldersInFolder(
    folderId: ID
    publicToken: String
    sort: FolderSortInput
    filter: FolderFilterInput
  ): [Folder!]!
  searchFiles(query: String!, search: String!): [File!]!
  getFolderDetails(folderId: ID, publicToken: String): Folder
}

extend type Mutation {
  getDownloadURL(fileId: ID!, publicToken: String): DownloadURL!

  createFolder(name: String!, parentId: ID): Folder! @auth
  deleteFile(fileId: ID!): Boolean! @auth
  deleteFolder(folderId: ID!): Boolean! @auth

  preUploadCheck(files: [PreUploadFileInput!]!): PreUploadCheckResponse! @auth
  confirmUploads(uploads: [ConfirmUploadInput!]!): ConfirmUploadsResponse! @auth
}
`, BuiltIn: false},
	{Name: "../schema/share.graphqls", Input: `type Share {
  id: ID!
  owner: User!
  sharedWith: User
  shareType: String!
  publicToken: String
  downloadCount: Int!
  createdAt: String!
}

extend type Query {
  getFileShares(fileId: ID!): [Share!]! @auth
  getFolderShares(folderId: ID!): [Share!]! @auth
  getMyShares: [Share!]! @auth
}

extend type Mutation {
  shareFileWithUser(fileId: ID!, email: String!): ID! @auth
  unshareFileWithUser(fileId: ID!, email: String!): Boolean! @auth

  shareFolderWithUser(folderId: ID!, email: String!): ID! @auth
  unshareFolderWithUser(folderId: ID!, email: String!): Boolean! @auth

  shareFilePublic(fileId: ID!): String! @auth
  shareFolderPublic(folderId: ID!): String! @auth
  revokePubliclyShared(publicToken: ID!): Boolean! @auth
}
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `type User {
  id: ID!
  name: String!
  email: String!
  role: String!
  createdAt: Time!
}

input RegisterUser {
  name: String!
  email: String!
  password: String!
}

input LoginUser {
  email: String!
  password: String!
}

type AuthResponse {
  user: User!
  token: String!
}

extend type Mutation {
  registerUser(input: RegisterUser!): AuthResponse!
  login(input: LoginUser!): AuthResponse!
}

extend type Query {
  me: User! @auth
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
