// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/YuanziX/files-backend/internal/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	File() FileResolver
	Folder() FolderResolver
	Mutation() MutationResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
	Auth    func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	HasRole func(ctx context.Context, obj any, next graphql.Resolver, role model.Role) (res any, err error)
}

type ComplexityRoot struct {
	AuthResponse struct {
		Token func(childComplexity int) int
		User  func(childComplexity int) int
	}

	File struct {
		Filename   func(childComplexity int) int
		ID         func(childComplexity int) int
		MimeType   func(childComplexity int) int
		Size       func(childComplexity int) int
		UploadDate func(childComplexity int) int
	}

	Folder struct {
		ChildrenFiles   func(childComplexity int) int
		ChildrenFolders func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		ID              func(childComplexity int) int
		Name            func(childComplexity int) int
		Parent          func(childComplexity int) int
	}

	Mutation struct {
		ConfirmUploads func(childComplexity int, uploads []*model.ConfirmUploadInput) int
		CreateFolder   func(childComplexity int, name string, parentID *string) int
		DeleteFile     func(childComplexity int, fileID string) int
		Login          func(childComplexity int, input model.LoginUser) int
		PreUploadCheck func(childComplexity int, files []*model.PreUploadFileInput) int
		RegisterUser   func(childComplexity int, input model.RegisterUser) int
	}

	PreSignedURL struct {
		Filename  func(childComplexity int) int
		Hash      func(childComplexity int) int
		UploadURL func(childComplexity int) int
	}

	PreUploadCheckResponse struct {
		CompletedFiles func(childComplexity int) int
		NewFiles       func(childComplexity int) int
	}

	Query struct {
		FolderDetails func(childComplexity int, folderID string) int
		Me            func(childComplexity int) int
		MyFiles       func(childComplexity int) int
		MyFolders     func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		Role      func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "AuthResponse.token":
		if e.complexity.AuthResponse.Token == nil {
			break
		}

		return e.complexity.AuthResponse.Token(childComplexity), true

	case "AuthResponse.user":
		if e.complexity.AuthResponse.User == nil {
			break
		}

		return e.complexity.AuthResponse.User(childComplexity), true

	case "File.filename":
		if e.complexity.File.Filename == nil {
			break
		}

		return e.complexity.File.Filename(childComplexity), true

	case "File.id":
		if e.complexity.File.ID == nil {
			break
		}

		return e.complexity.File.ID(childComplexity), true

	case "File.mimeType":
		if e.complexity.File.MimeType == nil {
			break
		}

		return e.complexity.File.MimeType(childComplexity), true

	case "File.size":
		if e.complexity.File.Size == nil {
			break
		}

		return e.complexity.File.Size(childComplexity), true

	case "File.uploadDate":
		if e.complexity.File.UploadDate == nil {
			break
		}

		return e.complexity.File.UploadDate(childComplexity), true

	case "Folder.childrenFiles":
		if e.complexity.Folder.ChildrenFiles == nil {
			break
		}

		return e.complexity.Folder.ChildrenFiles(childComplexity), true

	case "Folder.childrenFolders":
		if e.complexity.Folder.ChildrenFolders == nil {
			break
		}

		return e.complexity.Folder.ChildrenFolders(childComplexity), true

	case "Folder.createdAt":
		if e.complexity.Folder.CreatedAt == nil {
			break
		}

		return e.complexity.Folder.CreatedAt(childComplexity), true

	case "Folder.id":
		if e.complexity.Folder.ID == nil {
			break
		}

		return e.complexity.Folder.ID(childComplexity), true

	case "Folder.name":
		if e.complexity.Folder.Name == nil {
			break
		}

		return e.complexity.Folder.Name(childComplexity), true

	case "Folder.parent":
		if e.complexity.Folder.Parent == nil {
			break
		}

		return e.complexity.Folder.Parent(childComplexity), true

	case "Mutation.confirmUploads":
		if e.complexity.Mutation.ConfirmUploads == nil {
			break
		}

		args, err := ec.field_Mutation_confirmUploads_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ConfirmUploads(childComplexity, args["uploads"].([]*model.ConfirmUploadInput)), true

	case "Mutation.createFolder":
		if e.complexity.Mutation.CreateFolder == nil {
			break
		}

		args, err := ec.field_Mutation_createFolder_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateFolder(childComplexity, args["name"].(string), args["parentId"].(*string)), true

	case "Mutation.deleteFile":
		if e.complexity.Mutation.DeleteFile == nil {
			break
		}

		args, err := ec.field_Mutation_deleteFile_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteFile(childComplexity, args["fileId"].(string)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.LoginUser)), true

	case "Mutation.preUploadCheck":
		if e.complexity.Mutation.PreUploadCheck == nil {
			break
		}

		args, err := ec.field_Mutation_preUploadCheck_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PreUploadCheck(childComplexity, args["files"].([]*model.PreUploadFileInput)), true

	case "Mutation.registerUser":
		if e.complexity.Mutation.RegisterUser == nil {
			break
		}

		args, err := ec.field_Mutation_registerUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterUser(childComplexity, args["input"].(model.RegisterUser)), true

	case "PreSignedURL.filename":
		if e.complexity.PreSignedURL.Filename == nil {
			break
		}

		return e.complexity.PreSignedURL.Filename(childComplexity), true

	case "PreSignedURL.hash":
		if e.complexity.PreSignedURL.Hash == nil {
			break
		}

		return e.complexity.PreSignedURL.Hash(childComplexity), true

	case "PreSignedURL.uploadURL":
		if e.complexity.PreSignedURL.UploadURL == nil {
			break
		}

		return e.complexity.PreSignedURL.UploadURL(childComplexity), true

	case "PreUploadCheckResponse.completedFiles":
		if e.complexity.PreUploadCheckResponse.CompletedFiles == nil {
			break
		}

		return e.complexity.PreUploadCheckResponse.CompletedFiles(childComplexity), true

	case "PreUploadCheckResponse.newFiles":
		if e.complexity.PreUploadCheckResponse.NewFiles == nil {
			break
		}

		return e.complexity.PreUploadCheckResponse.NewFiles(childComplexity), true

	case "Query.folderDetails":
		if e.complexity.Query.FolderDetails == nil {
			break
		}

		args, err := ec.field_Query_folderDetails_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FolderDetails(childComplexity, args["folderId"].(string)), true

	case "Query.me":
		if e.complexity.Query.Me == nil {
			break
		}

		return e.complexity.Query.Me(childComplexity), true

	case "Query.myFiles":
		if e.complexity.Query.MyFiles == nil {
			break
		}

		return e.complexity.Query.MyFiles(childComplexity), true

	case "Query.myFolders":
		if e.complexity.Query.MyFolders == nil {
			break
		}

		return e.complexity.Query.MyFolders(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputConfirmUploadInput,
		ec.unmarshalInputLoginUser,
		ec.unmarshalInputPreUploadFileInput,
		ec.unmarshalInputRegisterUser,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/directives.graphqls", Input: `directive @auth on FIELD_DEFINITION

directive @hasRole(role: Role!) on FIELD_DEFINITION

enum Role {
  admin
  user
}
`, BuiltIn: false},
	{Name: "../schema/files.graphqls", Input: `scalar Time

type File {
  id: ID!
  filename: String!
  mimeType: String!
  size: Int!
  uploadDate: Time!
}

type Folder {
  id: ID!
  name: String!
  createdAt: Time!
  parent: Folder
  childrenFolders: [Folder!]!
  childrenFiles: [File!]!
}

type PreSignedURL {
  filename: String!
  hash: String!
  uploadURL: String!
}

type PreUploadCheckResponse {
  completedFiles: [File!]!
  newFiles: [PreSignedURL!]!
}

input PreUploadFileInput {
  filename: String!
  folderId: ID
  hash: String!
}

input ConfirmUploadInput {
  filename: String!
  hash: String!
  size: Int!
  mimeType: String!
  folderId: ID
}

extend type Query {
  myFiles: [File!]! @auth
  myFolders: [Folder!]! @auth
  folderDetails(folderId: ID!): Folder @auth
}

extend type Mutation {
  preUploadCheck(files: [PreUploadFileInput!]!): PreUploadCheckResponse! @auth
  confirmUploads(uploads: [ConfirmUploadInput!]!): [File!]! @auth
  createFolder(name: String!, parentId: ID): Folder! @auth
  deleteFile(fileId: ID!): Boolean! @auth
}
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `type User {
  id: ID!
  name: String!
  email: String!
  role: String!
  createdAt: Time!
}

input RegisterUser {
  name: String!
  email: String!
  password: String!
}

input LoginUser {
  email: String!
  password: String!
}

type AuthResponse {
  user: User!
  token: String!
}

extend type Mutation {
  registerUser(input: RegisterUser!): AuthResponse!
  login(input: LoginUser!): AuthResponse!
}

extend type Query {
  me: User! @auth
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
