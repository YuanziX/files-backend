package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"io"
	"log"
	"strings"
	"time"

	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/generated"
	"github.com/YuanziX/files-backend/internal/graph/model"
	"github.com/YuanziX/files-backend/internal/utils"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/gabriel-vasile/mimetype"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// ID is the resolver for the id field.
func (r *folderResolver) ID(ctx context.Context, obj *postgres.Folder) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *folderResolver) CreatedAt(ctx context.Context, obj *postgres.Folder) (*time.Time, error) {
	return &obj.CreatedAt.Time, nil
}

// ParentID is the resolver for the parentID field.
func (r *folderResolver) ParentID(ctx context.Context, obj *postgres.Folder) (*string, error) {
	str := obj.ParentID.String()
	return &str, nil
}

// ChildrenFolders is the resolver for the childrenFolders field.
func (r *folderResolver) ChildrenFolders(ctx context.Context, obj *postgres.Folder) ([]*postgres.Folder, error) {
	folderID := obj.ID.String()
	return r.Resolver.Query().GetFoldersInFolder(ctx, &folderID, nil, nil, nil)
}

// ChildrenFiles is the resolver for the childrenFiles field.
func (r *folderResolver) ChildrenFiles(ctx context.Context, obj *postgres.Folder) ([]*model.File, error) {
	folderID := obj.ID.String()
	return r.Resolver.Query().GetFilesInFolder(ctx, &folderID, nil, nil, nil)
}

// GetDownloadURL is the resolver for the getDownloadURL field.
func (r *mutationResolver) GetDownloadURL(ctx context.Context, fileID string, publicToken *string) (*model.DownloadURL, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid fileId")
	}

	fileToDownload, err := r.DB.GetFileForDownload(ctx, pgtype.UUID{Bytes: fileUUID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("file not found")
	}

	token := utils.GetPgString(publicToken)

	canAccessFile, err := r.DB.CanAccessFile(ctx, postgres.CanAccessFileParams{
		FileID:           pgtype.UUID{Bytes: fileUUID, Valid: true},
		PublicToken:      token,
		SharedWithUserID: userID,
	})

	if err != nil {
		return nil, fmt.Errorf("error checking file access: %w", err)
	}

	isOwner := fileToDownload.OwnerID.Bytes == userID.Bytes
	if !isOwner && !canAccessFile {
		return nil, fmt.Errorf("permission denied")
	}

	expiry := 10 * time.Minute
	objectKey := fileToDownload.ContentHash

	req, err := r.S3PresignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket:                     &r.Cfg.S3BucketName,
		Key:                        &objectKey,
		ResponseContentDisposition: aws.String(fmt.Sprintf(`attachment; filename="%s"`, fileToDownload.Filename)),
	}, s3.WithPresignExpires(expiry))
	if err != nil {
		return nil, fmt.Errorf("could not generate download URL: %w", err)
	}

	return &model.DownloadURL{
		DownloadURL: req.URL,
		Filename:    fileToDownload.Filename,
	}, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var pgParentID pgtype.UUID
	var newPath string
	var realPath string
	newFolderID := uuid.New() // Generate the new UUID ahead of time

	if parentID != nil {
		parentUUID := utils.GetPgUUID(parentID)
		if !parentUUID.Valid {
			return nil, fmt.Errorf("invalid parentId")
		}

		// Fetch the parent folder's path to build the new path.
		parentPath, err := r.DB.GetFolderPath(ctx, postgres.GetFolderPathParams{
			ID:      parentUUID,
			OwnerID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("parent folder not found")
		}

		newPath = fmt.Sprintf("%s.%s", parentPath.Path, strings.ReplaceAll(newFolderID.String(), "-", "_"))
		pgParentID = parentUUID
		realPath = fmt.Sprintf("%s%s/", parentPath.RealPath, name)
	} else {
		newPath = strings.ReplaceAll(newFolderID.String(), "-", "_")
		realPath = fmt.Sprintf("%s/", name)
	}

	params := postgres.CreateFolderParams{
		ID:       pgtype.UUID{Bytes: newFolderID, Valid: true},
		OwnerID:  userID,
		ParentID: pgParentID,
		Name:     name,
		Path:     newPath,
		RealPath: realPath,
	}

	newFolder, err := r.DB.CreateFolder(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create folder: %w", err)
	}
	return &postgres.Folder{
		ID:        newFolder.ID,
		Name:      newFolder.Name,
		ParentID:  newFolder.ParentID,
		Path:      newFolder.Path,
		CreatedAt: newFolder.CreatedAt,
		RealPath:  newFolder.RealPath,
	}, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return false, fmt.Errorf("access denied")
	}

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return false, fmt.Errorf("invalid fileId")
	}

	// ensure file exists and belongs to user
	requestedFile, err := r.DB.GetFileByIdAndOwner(ctx, postgres.GetFileByIdAndOwnerParams{
		ID:      fileUUID,
		OwnerID: userID,
	})

	if err != nil || (requestedFile.OwnerID != userID) {
		return false, fmt.Errorf("file not found, or invalid permissions: %w", err)
	}

	err = r.DB.DeleteFileReference(ctx, fileUUID)
	if err != nil {
		return false, fmt.Errorf("failed to delete file reference: %w", err)
	}

	// decrement physical file refs
	err = r.DB.DecrementPhysicalFileReferenceCount(ctx, requestedFile.PhysicalFileID)
	if err != nil {
		return false, fmt.Errorf("failed to decrement references: %w", err)
	}

	return true, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, folderID string) (bool, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return false, fmt.Errorf("access denied")
	}

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return false, fmt.Errorf("invalid folderId")
	}

	// ensure folder exists and belongs to user
	requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)

	if err != nil || (requestedFolder.OwnerID != userID) {
		return false, fmt.Errorf("folder not found, or invalid permissions: %w", err)
	}

	// start transaction
	tx, err := r.DBPool.Begin(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to start transaction: %w", err)
	}
	qtx := r.DB.WithTx(&tx)

	// decrement physical file refs
	if err := qtx.DecrementPhysicalFileRefsInFolder(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to decrement references: %w", err)
	}

	// delete files
	if err := qtx.DeleteFilesInFolder(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to delete files: %w", err)
	}

	// delete folders
	if err := qtx.DeleteFoldersRecursively(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to delete folders: %w", err)
	}

	// commit transaction
	if err := tx.Commit(ctx); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return true, nil
}

// PreUploadCheck is the resolver for the preUploadCheck field.
func (r *mutationResolver) PreUploadCheck(ctx context.Context, files []*model.PreUploadFileInput) (*model.PreUploadCheckResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var completedFiles []*model.File
	var newFiles []*model.PreSignedURL

	for _, fileInput := range files {
		physicalFile, err := r.DB.GetPhysicalFileByHash(ctx, fileInput.Hash)

		if err == nil {
			var pgFolderID pgtype.UUID
			if fileInput.FolderID != nil {
				parsedFolderID, err := uuid.Parse(*fileInput.FolderID)
				if err != nil {
					return nil, fmt.Errorf("invalid folder ID: %w", err)
				}
				pgFolderID = pgtype.UUID{Bytes: parsedFolderID, Valid: true}
			}

			params := postgres.CreateFileReferenceParams{
				OwnerID:        userID,
				PhysicalFileID: physicalFile.ID,
				FolderID:       pgFolderID,
				Filename:       fileInput.Filename,
			}
			newFileRef, _ := r.DB.CreateFileReference(ctx, params)

			completedFiles = append(completedFiles, &model.File{
				ID:         newFileRef.ID.String(),
				Filename:   newFileRef.Filename,
				UploadDate: newFileRef.UploadDate.Time,
			})
		} else {
			// New file
			objectName := fileInput.Hash
			expiry := 15 * time.Minute

			presignedURL, err := r.S3PresignClient.PresignPutObject(ctx, &s3.PutObjectInput{
				Bucket: &r.Cfg.S3BucketName,
				Key:    &objectName,
			}, s3.WithPresignExpires(expiry))

			if err != nil {
				return nil, fmt.Errorf("could not generate pre-signed URL for %s: %w", fileInput.Filename, err)
			}
			newFiles = append(newFiles, &model.PreSignedURL{
				Filename:  fileInput.Filename,
				Hash:      fileInput.Hash,
				UploadURL: presignedURL.URL,
			})
		}
	}

	return &model.PreUploadCheckResponse{
		CompletedFiles: completedFiles,
		NewFiles:       newFiles,
	}, nil
}

// ConfirmUploads is the resolver for the confirmUploads field.
func (r *mutationResolver) ConfirmUploads(ctx context.Context, uploads []*model.ConfirmUploadInput) (*model.ConfirmUploadsResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var confirmedFiles []*model.File
	var failedUploads []*model.FailedUpload

	for _, upload := range uploads {
		tx, err := r.DBPool.Begin(ctx)
		if err != nil {
			return nil, err
		}
		qtx := r.DB.WithTx(&tx)

		object, err := r.S3Client.GetObject(ctx, &s3.GetObjectInput{
			Bucket: &r.Cfg.S3BucketName,
			Key:    &upload.Hash,
			Range:  aws.String("bytes=0-511"),
		})
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Object not found"})
			log.Printf("Failed to get object for hash %s: %v", upload.Hash, err)
			continue
		}

		data, err := io.ReadAll(object.Body)
		object.Body.Close()
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to read magic bytes"})
			log.Printf("Failed to read magic bytes for hash %s: %v", upload.Hash, err)
			continue
		}

		detectedMIME := mimetype.Detect(data).String()
		verifiedPrimary := utils.ExtractPrimaryMIME(detectedMIME)
		expectedPrimary := utils.ExtractPrimaryMIME(upload.MimeType)

		if !utils.IsMimeMatch(verifiedPrimary, expectedPrimary) {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "MIME mismatch"})
			log.Printf("MIME mismatch for hash %s: client said %s, detected %s",
				upload.Hash, upload.MimeType, detectedMIME)
			continue
		}

		validSize, err := utils.VerifySize(*object.ContentRange, upload.Size)
		if err != nil || !validSize {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Size mismatch"})
			log.Printf("Size mismatch for hash %s: client %d, server %s", upload.Hash, upload.Size, *object.ContentRange)
			continue
		}

		physFileParams := postgres.CreatePhysicalFileParams{
			ContentHash: upload.Hash,
			MimeType:    upload.MimeType,
			SizeBytes:   int64(upload.Size),
			StoragePath: fmt.Sprintf("%s/%s", r.Cfg.S3BucketName, upload.Hash),
		}

		physicalFile, err := qtx.CreatePhysicalFile(ctx, physFileParams)
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to create physical file"})
			tx.Rollback(ctx)
			continue
		}

		var pgFolderID pgtype.UUID
		if upload.FolderID != nil {
			if parsedFolderID, err := uuid.Parse(*upload.FolderID); err == nil {
				pgFolderID = pgtype.UUID{Bytes: parsedFolderID, Valid: true}
			}
		}

		fileRefParams := postgres.CreateFileReferenceParams{
			OwnerID:        userID,
			PhysicalFileID: physicalFile.ID,
			FolderID:       pgFolderID,
			Filename:       upload.Filename,
		}
		newFile, err := qtx.CreateFileReference(ctx, fileRefParams)
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to create file reference"})
			tx.Rollback(ctx)
			continue
		}

		if err := tx.Commit(ctx); err != nil {
			return nil, err
		}

		confirmedFiles = append(confirmedFiles, &model.File{
			ID:         newFile.ID.String(),
			Filename:   newFile.Filename,
			UploadDate: newFile.UploadDate.Time,
		})
	}
	return &model.ConfirmUploadsResponse{
		Files:         confirmedFiles,
		FailedUploads: failedUploads,
	}, nil
}

// GetFile is the resolver for the getFile field.
func (r *queryResolver) GetFile(ctx context.Context, fileID string, publicToken *string) (*model.File, error) {
	userID := utils.GetUserID(ctx)

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return nil, fmt.Errorf("invalid fileId")
	}

	requestedFile, err := r.DB.GetFileById(ctx, fileUUID)
	if err != nil {
		return nil, fmt.Errorf("file not found: %w", err)
	}

	// Check if user is owner (when authenticated)
	if userID.Valid && requestedFile.OwnerID == userID {
		return &model.File{
			ID:         requestedFile.ID.String(),
			Filename:   requestedFile.Filename,
			UploadDate: requestedFile.UploadDate.Time,
			Size:       int32(requestedFile.SizeBytes),
			MimeType:   requestedFile.MimeType,
		}, nil
	}

	// Check public access
	if publicToken != nil {
		canAccess, err := r.DB.CanAccessFile(ctx, postgres.CanAccessFileParams{
			FileID:           fileUUID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking file access: %w", err)
		}

		if canAccess {
			return &model.File{
				ID:         requestedFile.ID.String(),
				Filename:   requestedFile.Filename,
				UploadDate: requestedFile.UploadDate.Time,
				Size:       int32(requestedFile.SizeBytes),
				MimeType:   requestedFile.MimeType,
			}, nil
		}
	}

	// No valid access method
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}
	return nil, fmt.Errorf("permission denied")
}

// GetFilesInFolder is the resolver for the getFilesInFolder field.
func (r *queryResolver) GetFilesInFolder(ctx context.Context, folderID *string, publicToken *string, sort *model.FileSortInput, filter *model.FileFilterInput) ([]*model.File, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	var files []*model.File
	if publicToken != nil && folderID == nil {
		folderIDFromDB, err := r.DB.GetFolderIdByPublicToken(ctx, utils.GetPgString(publicToken))

		if err != nil {
			return nil, fmt.Errorf("invalid public token or no access to any folder with this token")
		}

		folderUUID := uuid.UUID(folderIDFromDB.Bytes)
		folderIDStr := folderUUID.String()
		folderID = &folderIDStr
	}

	// Build sort and filter parameters
	sortField, sortOrder := utils.BuildFileSortParams(sort)
	filename, mimeType, minSize, maxSize, uploadedAfter, uploadedBefore := utils.BuildFileFilterParams(filter)

	if folderID == nil && publicToken == nil {
		// Root files for authenticated user with sorting and filtering
		rootFiles, err := r.DB.ListRootFilesByOwnerWithSortAndFilter(ctx, postgres.ListRootFilesByOwnerWithSortAndFilterParams{
			OwnerID:        userID,
			SortField:      utils.GetPgString(sortField),
			SortOrder:      utils.GetPgString(sortOrder),
			FilenameFilter: utils.GetPgString(filename),
			MimeTypeFilter: utils.GetPgString(mimeType),
			MinSize:        utils.GetPgInt8(minSize),
			MaxSize:        utils.GetPgInt8(maxSize),
			UploadedAfter:  utils.GetPgTime(uploadedAfter),
			UploadedBefore: utils.GetPgTime(uploadedBefore),
		})
		if err != nil {
			return nil, err
		}

		for _, f := range rootFiles {
			files = append(files, &model.File{
				ID:         f.ID.String(),
				Filename:   f.Filename,
				UploadDate: f.UploadDate.Time,
				Size:       int32(f.SizeBytes),
				MimeType:   f.MimeType,
			})
		}

	} else {
		folderUUID := utils.GetPgUUID(folderID)
		if !folderUUID.Valid {
			return nil, fmt.Errorf("invalid folderId")
		}

		requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)
		if err != nil {
			return nil, fmt.Errorf("folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		// Files in folder with sorting and filtering
		folderFiles, err := r.DB.ListFilesByFolderWithSortAndFilter(ctx, postgres.ListFilesByFolderWithSortAndFilterParams{
			FolderID:       folderUUID,
			SortField:      utils.GetPgString(sortField),
			SortOrder:      utils.GetPgString(sortOrder),
			FilenameFilter: utils.GetPgString(filename),
			MimeTypeFilter: utils.GetPgString(mimeType),
			MinSize:        utils.GetPgInt8(minSize),
			MaxSize:        utils.GetPgInt8(maxSize),
			UploadedAfter:  utils.GetPgTime(uploadedAfter),
			UploadedBefore: utils.GetPgTime(uploadedBefore),
		})
		if err != nil {
			return nil, err
		}
		for _, f := range folderFiles {
			files = append(files, &model.File{
				ID:         f.ID.String(),
				Filename:   f.Filename,
				UploadDate: f.UploadDate.Time,
				Size:       int32(f.SizeBytes),
				MimeType:   f.MimeType,
			})
		}
	}

	return files, nil
}

// GetFoldersInFolder is the resolver for the getFoldersInFolder field.
func (r *queryResolver) GetFoldersInFolder(ctx context.Context, folderID *string, publicToken *string, sort *model.FolderSortInput, filter *model.FolderFilterInput) ([]*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	var folders []*postgres.Folder
	if publicToken != nil && folderID == nil {
		folderIDFromDB, err := r.DB.GetFolderIdByPublicToken(ctx, utils.GetPgString(publicToken))
		if err != nil {
			return nil, fmt.Errorf("invalid public token or no access to any folder with this token")
		}

		folderUUID := uuid.UUID(folderIDFromDB.Bytes)
		folderIDStr := folderUUID.String()
		folderID = &folderIDStr
	}

	// Build sort and filter parameters
	sortField, sortOrder := utils.BuildFolderSortParams(sort)
	name, createdAfter, createdBefore := utils.BuildFolderFilterParams(filter)

	if folderID == nil && publicToken == nil {
		// Root folders for authenticated user with sorting and filtering
		rootFolders, err := r.DB.ListRootFoldersByOwnerWithSortAndFilter(ctx, postgres.ListRootFoldersByOwnerWithSortAndFilterParams{
			OwnerID:       userID,
			SortField:     utils.GetPgString(sortField),
			SortOrder:     utils.GetPgString(sortOrder),
			NameFilter:    utils.GetPgString(name),
			CreatedAfter:  utils.GetPgTime(createdAfter),
			CreatedBefore: utils.GetPgTime(createdBefore),
		})
		if err != nil {
			return nil, err
		}

		for _, f := range rootFolders {
			folders = append(folders, &postgres.Folder{
				ID:        f.ID,
				Name:      f.Name,
				CreatedAt: f.CreatedAt,
				ParentID:  f.ParentID,
				Path:      f.Path,
				OwnerID:   f.OwnerID,
			})
		}

	} else {
		folderUUID := utils.GetPgUUID(folderID)
		if !folderUUID.Valid {
			return nil, fmt.Errorf("invalid folderId")
		}

		requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)
		if err != nil {
			return nil, fmt.Errorf("folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		// Subfolders with sorting and filtering
		folderFiles, err := r.DB.ListSubfoldersByParentWithSortAndFilter(ctx, postgres.ListSubfoldersByParentWithSortAndFilterParams{
			ParentID:      folderUUID,
			SortField:     utils.GetPgString(sortField),
			SortOrder:     utils.GetPgString(sortOrder),
			NameFilter:    utils.GetPgString(name),
			CreatedAfter:  utils.GetPgTime(createdAfter),
			CreatedBefore: utils.GetPgTime(createdBefore),
		})
		if err != nil {
			return nil, err
		}
		for _, f := range folderFiles {
			folders = append(folders, &postgres.Folder{
				ID:        f.ID,
				Name:      f.Name,
				CreatedAt: f.CreatedAt,
				ParentID:  f.ParentID,
				Path:      f.Path,
				OwnerID:   f.OwnerID,
			})
		}
	}

	return folders, nil
}

// SearchFiles is the resolver for the searchFiles field.
func (r *queryResolver) SearchFiles(ctx context.Context, query string, search string) ([]*model.File, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	if len(strings.TrimSpace(search)) < 3 {
		return nil, fmt.Errorf("search term must be at least 3 characters long")
	}

	var files []*model.File

	searchResults, err := r.DB.SearchAllFilesByOwner(ctx, postgres.SearchAllFilesByOwnerParams{
		OwnerID: userID,
		Column2: utils.GetPgString(&query),
	})
	if err != nil {
		return nil, fmt.Errorf("search query failed: %w", err)
	}

	for _, f := range searchResults {
		if strings.Contains(strings.ToLower(f.Filename), strings.ToLower(search)) {
			files = append(files, &model.File{
				ID:         f.ID.String(),
				Filename:   f.Filename,
				UploadDate: f.UploadDate.Time,
				Size:       int32(f.SizeBytes),
				MimeType:   f.MimeType,
			})
		}
	}

	return files, nil
}

// GetFolderDetails is the resolver for the getFolderDetails field.
func (r *queryResolver) GetFolderDetails(ctx context.Context, folderID string, publicToken *string) (*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return nil, fmt.Errorf("invalid folderId")
	}

	folder, err := r.DB.GetFolderByID(ctx, folderUUID)
	if err != nil {
		return nil, fmt.Errorf("folder not found")
	}

	canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
		ID:               folder.ID,
		PublicToken:      utils.GetPgString(publicToken),
		SharedWithUserID: userID,
	})
	if err != nil {
		return nil, fmt.Errorf("error checking folder access: %w", err)
	}

	if (folder.OwnerID != userID) && !canAccessFolder {
		return nil, fmt.Errorf("permission denied")
	}

	return &folder, nil
}

// Folder returns generated.FolderResolver implementation.
func (r *Resolver) Folder() generated.FolderResolver { return &folderResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type folderResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
