package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"io"
	"log"
	"strings"
	"time"

	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/generated"
	"github.com/YuanziX/files-backend/internal/graph/model"
	"github.com/YuanziX/files-backend/internal/utils"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"github.com/gabriel-vasile/mimetype"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

// ID is the resolver for the id field.
func (r *folderResolver) ID(ctx context.Context, obj *postgres.Folder) (string, error) {
	return obj.ID.String(), nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *folderResolver) CreatedAt(ctx context.Context, obj *postgres.Folder) (*time.Time, error) {
	return &obj.CreatedAt.Time, nil
}

// ParentID is the resolver for the parentID field.
func (r *folderResolver) ParentID(ctx context.Context, obj *postgres.Folder) (*string, error) {
	str := obj.ParentID.String()
	return &str, nil
}

// ChildrenFolders is the resolver for the childrenFolders field.
func (r *folderResolver) ChildrenFolders(ctx context.Context, obj *postgres.Folder) ([]*postgres.Folder, error) {
	folderID := obj.ID.String()
	return r.Resolver.Query().GetFoldersInFolder(ctx, &folderID, nil)
}

// ChildrenFiles is the resolver for the childrenFiles field.
func (r *folderResolver) ChildrenFiles(ctx context.Context, obj *postgres.Folder) ([]*model.File, error) {
	folderID := obj.ID.String()
	return r.Resolver.Query().GetFilesInFolder(ctx, &folderID, nil)
}

// GetDownloadURL is the resolver for the getDownloadURL field.
func (r *mutationResolver) GetDownloadURL(ctx context.Context, fileID string, publicToken *string) (*model.DownloadURL, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid fileId")
	}

	fileToDownload, err := r.DB.GetFileForDownload(ctx, pgtype.UUID{Bytes: fileUUID, Valid: true})
	if err != nil {
		return nil, fmt.Errorf("file not found")
	}

	token := utils.GetPgString(publicToken)

	canAccessFile, err := r.DB.CanAccessFile(ctx, postgres.CanAccessFileParams{
		FileID:           pgtype.UUID{Bytes: fileUUID, Valid: true},
		PublicToken:      token,
		SharedWithUserID: userID,
	})

	if err != nil {
		return nil, fmt.Errorf("error checking file access: %w", err)
	}

	isOwner := fileToDownload.OwnerID.Bytes == userID.Bytes
	if !isOwner && !canAccessFile {
		return nil, fmt.Errorf("permission denied")
	}

	expiry := 10 * time.Minute
	objectKey := fileToDownload.ContentHash

	req, err := r.S3PresignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket:                     &r.Cfg.S3BucketName,
		Key:                        &objectKey,
		ResponseContentDisposition: aws.String(fmt.Sprintf(`attachment; filename="%s"`, fileToDownload.Filename)),
	}, s3.WithPresignExpires(expiry))
	if err != nil {
		return nil, fmt.Errorf("could not generate download URL: %w", err)
	}

	return &model.DownloadURL{
		DownloadURL: req.URL,
		Filename:    fileToDownload.Filename,
	}, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var pgParentID pgtype.UUID
	var newPath string
	var realPath string
	newFolderID := uuid.New() // Generate the new UUID ahead of time

	if parentID != nil {
		parentUUID := utils.GetPgUUID(parentID)
		if !parentUUID.Valid {
			return nil, fmt.Errorf("invalid parentId")
		}

		// Fetch the parent folder's path to build the new path.
		parentPath, err := r.DB.GetFolderPath(ctx, postgres.GetFolderPathParams{
			ID:      parentUUID,
			OwnerID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("parent folder not found")
		}

		newPath = fmt.Sprintf("%s.%s", parentPath.Path, strings.ReplaceAll(newFolderID.String(), "-", "_"))
		pgParentID = parentUUID
		realPath = fmt.Sprintf("%s%s/", parentPath.RealPath, name)
	} else {
		newPath = strings.ReplaceAll(newFolderID.String(), "-", "_")
		realPath = fmt.Sprintf("%s/", name)
	}

	params := postgres.CreateFolderParams{
		ID:       pgtype.UUID{Bytes: newFolderID, Valid: true},
		OwnerID:  userID,
		ParentID: pgParentID,
		Name:     name,
		Path:     newPath,
		RealPath: realPath,
	}

	newFolder, err := r.DB.CreateFolder(ctx, params)
	if err != nil {
		return nil, fmt.Errorf("failed to create folder: %w", err)
	}
	return &postgres.Folder{
		ID:        newFolder.ID,
		Name:      newFolder.Name,
		ParentID:  newFolder.ParentID,
		Path:      newFolder.Path,
		CreatedAt: newFolder.CreatedAt,
		RealPath:  newFolder.RealPath,
	}, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return false, fmt.Errorf("access denied")
	}

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return false, fmt.Errorf("invalid fileId")
	}

	// ensure file exists and belongs to user
	requestedFile, err := r.DB.GetFileByIdAndOwner(ctx, postgres.GetFileByIdAndOwnerParams{
		ID:      fileUUID,
		OwnerID: userID,
	})

	if err != nil || (requestedFile.OwnerID != userID) {
		return false, fmt.Errorf("file not found, or invalid permissions: %w", err)
	}

	err = r.DB.DeleteFileReference(ctx, fileUUID)
	if err != nil {
		return false, fmt.Errorf("failed to delete file reference: %w", err)
	}

	// decrement physical file refs
	err = r.DB.DecrementPhysicalFileReferenceCount(ctx, requestedFile.PhysicalFileID)
	if err != nil {
		return false, fmt.Errorf("failed to decrement references: %w", err)
	}

	return true, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, folderID string) (bool, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return false, fmt.Errorf("access denied")
	}

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return false, fmt.Errorf("invalid folderId")
	}

	// ensure folder exists and belongs to user
	requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)

	if err != nil || (requestedFolder.OwnerID != userID) {
		return false, fmt.Errorf("folder not found, or invalid permissions: %w", err)
	}

	// start transaction
	tx, err := r.DBPool.Begin(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to start transaction: %w", err)
	}
	qtx := r.DB.WithTx(&tx)

	// decrement physical file refs
	if err := qtx.DecrementPhysicalFileRefsInFolder(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to decrement references: %w", err)
	}

	// delete files
	if err := qtx.DeleteFilesInFolder(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to delete files: %w", err)
	}

	// delete folders
	if err := qtx.DeleteFoldersRecursively(ctx, folderUUID); err != nil {
		tx.Rollback(ctx)
		return false, fmt.Errorf("failed to delete folders: %w", err)
	}

	// commit transaction
	if err := tx.Commit(ctx); err != nil {
		return false, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return true, nil
}

// PreUploadCheck is the resolver for the preUploadCheck field.
func (r *mutationResolver) PreUploadCheck(ctx context.Context, files []*model.PreUploadFileInput) (*model.PreUploadCheckResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var completedFiles []*model.File
	var newFiles []*model.PreSignedURL

	for _, fileInput := range files {
		physicalFile, err := r.DB.GetPhysicalFileByHash(ctx, fileInput.Hash)

		if err == nil {
			var pgFolderID pgtype.UUID
			if fileInput.FolderID != nil {
				parsedFolderID, err := uuid.Parse(*fileInput.FolderID)
				if err != nil {
					return nil, fmt.Errorf("invalid folder ID: %w", err)
				}
				pgFolderID = pgtype.UUID{Bytes: parsedFolderID, Valid: true}
			}

			params := postgres.CreateFileReferenceParams{
				OwnerID:        userID,
				PhysicalFileID: physicalFile.ID,
				FolderID:       pgFolderID,
				Filename:       fileInput.Filename,
			}
			newFileRef, _ := r.DB.CreateFileReference(ctx, params)

			completedFiles = append(completedFiles, &model.File{
				ID:         newFileRef.ID.String(),
				Filename:   newFileRef.Filename,
				UploadDate: newFileRef.UploadDate.Time,
			})
		} else {
			// New file
			objectName := fileInput.Hash
			expiry := 15 * time.Minute

			presignedURL, err := r.S3PresignClient.PresignPutObject(ctx, &s3.PutObjectInput{
				Bucket: &r.Cfg.S3BucketName,
				Key:    &objectName,
			}, s3.WithPresignExpires(expiry))

			if err != nil {
				return nil, fmt.Errorf("could not generate pre-signed URL for %s: %w", fileInput.Filename, err)
			}
			newFiles = append(newFiles, &model.PreSignedURL{
				Filename:  fileInput.Filename,
				Hash:      fileInput.Hash,
				UploadURL: presignedURL.URL,
			})
		}
	}

	return &model.PreUploadCheckResponse{
		CompletedFiles: completedFiles,
		NewFiles:       newFiles,
	}, nil
}

// ConfirmUploads is the resolver for the confirmUploads field.
func (r *mutationResolver) ConfirmUploads(ctx context.Context, uploads []*model.ConfirmUploadInput) (*model.ConfirmUploadsResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid {
		return nil, fmt.Errorf("access denied")
	}

	var confirmedFiles []*model.File
	var failedUploads []*model.FailedUpload

	for _, upload := range uploads {
		tx, err := r.DBPool.Begin(ctx)
		if err != nil {
			return nil, err
		}
		qtx := r.DB.WithTx(&tx)

		object, err := r.S3Client.GetObject(ctx, &s3.GetObjectInput{
			Bucket: &r.Cfg.S3BucketName,
			Key:    &upload.Hash,
			Range:  aws.String("bytes=0-511"),
		})
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Object not found"})
			log.Printf("Failed to get object for hash %s: %v", upload.Hash, err)
			continue
		}

		data, err := io.ReadAll(object.Body)
		object.Body.Close()
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to read magic bytes"})
			log.Printf("Failed to read magic bytes for hash %s: %v", upload.Hash, err)
			continue
		}

		detectedMIME := mimetype.Detect(data).String()
		verifiedPrimary := utils.ExtractPrimaryMIME(detectedMIME)
		expectedPrimary := utils.ExtractPrimaryMIME(upload.MimeType)

		if !utils.IsMimeMatch(verifiedPrimary, expectedPrimary) {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "MIME mismatch"})
			log.Printf("MIME mismatch for hash %s: client said %s, detected %s",
				upload.Hash, upload.MimeType, detectedMIME)
			continue
		}

		validSize, err := utils.VerifySize(*object.ContentRange, upload.Size)
		if err != nil || !validSize {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Size mismatch"})
			log.Printf("Size mismatch for hash %s: client %d, server %s", upload.Hash, upload.Size, *object.ContentRange)
			continue
		}

		physFileParams := postgres.CreatePhysicalFileParams{
			ContentHash: upload.Hash,
			MimeType:    upload.MimeType,
			SizeBytes:   int64(upload.Size),
			StoragePath: fmt.Sprintf("%s/%s", r.Cfg.S3BucketName, upload.Hash),
		}

		physicalFile, err := qtx.CreatePhysicalFile(ctx, physFileParams)
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to create physical file"})
			tx.Rollback(ctx)
			continue
		}

		var pgFolderID pgtype.UUID
		if upload.FolderID != nil {
			if parsedFolderID, err := uuid.Parse(*upload.FolderID); err == nil {
				pgFolderID = pgtype.UUID{Bytes: parsedFolderID, Valid: true}
			}
		}

		fileRefParams := postgres.CreateFileReferenceParams{
			OwnerID:        userID,
			PhysicalFileID: physicalFile.ID,
			FolderID:       pgFolderID,
			Filename:       upload.Filename,
		}
		newFile, err := qtx.CreateFileReference(ctx, fileRefParams)
		if err != nil {
			failedUploads = append(failedUploads, &model.FailedUpload{Hash: upload.Hash, Reason: "Failed to create file reference"})
			tx.Rollback(ctx)
			continue
		}

		if err := tx.Commit(ctx); err != nil {
			return nil, err
		}

		confirmedFiles = append(confirmedFiles, &model.File{
			ID:         newFile.ID.String(),
			Filename:   newFile.Filename,
			UploadDate: newFile.UploadDate.Time,
		})
	}
	return &model.ConfirmUploadsResponse{
		Files:         confirmedFiles,
		FailedUploads: failedUploads,
	}, nil
}

// GetFile is the resolver for the getFile field.
func (r *queryResolver) GetFile(ctx context.Context, fileID string, publicToken *string) (*model.File, error) {
	userID := utils.GetUserID(ctx)

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return nil, fmt.Errorf("invalid fileId")
	}

	requestedFile, err := r.DB.GetFileById(ctx, fileUUID)
	if err != nil {
		return nil, fmt.Errorf("file not found: %w", err)
	}

	// Check if user is owner (when authenticated)
	if userID.Valid && requestedFile.OwnerID == userID {
		return &model.File{
			ID:         requestedFile.ID.String(),
			Filename:   requestedFile.Filename,
			UploadDate: requestedFile.UploadDate.Time,
			Size:       int32(requestedFile.SizeBytes),
			MimeType:   requestedFile.MimeType,
		}, nil
	}

	// Check public access
	if publicToken != nil {
		canAccess, err := r.DB.CanAccessFile(ctx, postgres.CanAccessFileParams{
			FileID:           fileUUID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking file access: %w", err)
		}

		if canAccess {
			return &model.File{
				ID:         requestedFile.ID.String(),
				Filename:   requestedFile.Filename,
				UploadDate: requestedFile.UploadDate.Time,
				Size:       int32(requestedFile.SizeBytes),
				MimeType:   requestedFile.MimeType,
			}, nil
		}
	}

	// No valid access method
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}
	return nil, fmt.Errorf("permission denied")
}

// GetFiles is the resolver for the getFiles field.
func (r *queryResolver) GetFiles(ctx context.Context, filter *model.FileFilter, sort *model.FileSort, pagination *model.PaginationInput, folderID *string, publicToken *string) (*model.FilesResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Set default pagination
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			offset = int(*pagination.Offset)
		}
	}

	// Build the base query
	var baseQuery string
	var args []interface{}
	argIndex := 1

	if folderID != nil {
		// Get files in specific folder
		folderUUID := utils.GetPgUUID(folderID)
		if !folderUUID.Valid {
			return nil, fmt.Errorf("invalid folderId")
		}

		// Check folder access
		requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)
		if err != nil {
			return nil, fmt.Errorf("folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		baseQuery = `
			SELECT f.id, f.filename, f.upload_date, pf.mime_type, pf.size_bytes
			FROM files f
			JOIN physical_files pf ON f.physical_file_id = pf.id
			WHERE f.folder_id = $1`
		args = append(args, folderUUID)
		argIndex++
	} else {
		// Get root files for user
		baseQuery = `
			SELECT f.id, f.filename, f.upload_date, pf.mime_type, pf.size_bytes
			FROM files f
			JOIN physical_files pf ON f.physical_file_id = pf.id
			WHERE f.owner_id = $1 AND f.folder_id IS NULL`
		args = append(args, userID)
		argIndex++
	}

	// Apply filters
	if filter != nil {
		if filter.Filename != nil {
			baseQuery += fmt.Sprintf(" AND f.filename ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.Filename+"%")
			argIndex++
		}

		if filter.MimeType != nil {
			baseQuery += fmt.Sprintf(" AND pf.mime_type ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.MimeType+"%")
			argIndex++
		}

		if filter.MinSize != nil {
			baseQuery += fmt.Sprintf(" AND pf.size_bytes >= $%d", argIndex)
			args = append(args, *filter.MinSize)
			argIndex++
		}

		if filter.MaxSize != nil {
			baseQuery += fmt.Sprintf(" AND pf.size_bytes <= $%d", argIndex)
			args = append(args, *filter.MaxSize)
			argIndex++
		}

		if filter.UploadedAfter != nil {
			baseQuery += fmt.Sprintf(" AND f.upload_date > $%d", argIndex)
			args = append(args, *filter.UploadedAfter)
			argIndex++
		}

		if filter.UploadedBefore != nil {
			baseQuery += fmt.Sprintf(" AND f.upload_date < $%d", argIndex)
			args = append(args, *filter.UploadedBefore)
			argIndex++
		}
	}

	// Apply sorting
	orderBy := "ORDER BY f.filename ASC" // default
	if sort != nil {
		direction := "ASC"
		if sort.Direction == model.SortDirectionDesc {
			direction = "DESC"
		}

		switch sort.Field {
		case model.FileSortFieldFilename:
			orderBy = fmt.Sprintf("ORDER BY f.filename %s", direction)
		case model.FileSortFieldSize:
			orderBy = fmt.Sprintf("ORDER BY pf.size_bytes %s", direction)
		case model.FileSortFieldUploadDate:
			orderBy = fmt.Sprintf("ORDER BY f.upload_date %s", direction)
		case model.FileSortFieldMimeType:
			orderBy = fmt.Sprintf("ORDER BY pf.mime_type %s", direction)
		}
	}

	// Get total count first (without limit/offset)
	countQuery := strings.Replace(baseQuery, "SELECT f.id, f.filename, f.upload_date, pf.mime_type, pf.size_bytes", "SELECT COUNT(*)", 1)

	var totalCount int64
	err := r.DBPool.QueryRow(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	// Add pagination
	finalQuery := fmt.Sprintf("%s %s LIMIT $%d OFFSET $%d", baseQuery, orderBy, argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Execute query
	rows, err := r.DBPool.Query(ctx, finalQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var fileID pgtype.UUID
		var filename string
		var uploadDate pgtype.Timestamptz
		var mimeType string
		var sizeBytes int64

		err := rows.Scan(&fileID, &filename, &uploadDate, &mimeType, &sizeBytes)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		files = append(files, &model.File{
			ID:         fileID.String(),
			Filename:   filename,
			UploadDate: uploadDate.Time,
			MimeType:   mimeType,
			Size:       int32(sizeBytes),
		})
	}

	return &model.FilesResponse{
		Files:           files,
		TotalCount:      int32(totalCount),
		HasNextPage:     int64(offset+limit) < totalCount,
		HasPreviousPage: offset > 0,
	}, nil
}

// GetFolders is the resolver for the getFolders field.
func (r *queryResolver) GetFolders(ctx context.Context, filter *model.FolderFilter, sort *model.FolderSort, pagination *model.PaginationInput, parentID *string, publicToken *string) (*model.FoldersResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Set default pagination
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			offset = int(*pagination.Offset)
		}
	}

	// Build the base query
	var baseQuery string
	var args []interface{}
	argIndex := 1

	if parentID != nil {
		// Get subfolders
		parentUUID := utils.GetPgUUID(parentID)
		if !parentUUID.Valid {
			return nil, fmt.Errorf("invalid parentId")
		}

		// Check parent folder access
		requestedFolder, err := r.DB.GetFolderByID(ctx, parentUUID)
		if err != nil {
			return nil, fmt.Errorf("parent folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		baseQuery = `SELECT id, name, created_at, parent_id, path, real_path, owner_id FROM folders WHERE parent_id = $1`
		args = append(args, parentUUID)
		argIndex++
	} else {
		// Get root folders for user
		baseQuery = `SELECT id, name, created_at, parent_id, path, real_path, owner_id FROM folders WHERE owner_id = $1 AND parent_id IS NULL`
		args = append(args, userID)
		argIndex++
	}

	// Apply filters
	if filter != nil {
		if filter.Name != nil {
			baseQuery += fmt.Sprintf(" AND name ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.Name+"%")
			argIndex++
		}

		if filter.Path != nil {
			baseQuery += fmt.Sprintf(" AND path::text ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.Path+"%")
			argIndex++
		}

		if filter.CreatedAfter != nil {
			baseQuery += fmt.Sprintf(" AND created_at > $%d", argIndex)
			args = append(args, *filter.CreatedAfter)
			argIndex++
		}

		if filter.CreatedBefore != nil {
			baseQuery += fmt.Sprintf(" AND created_at < $%d", argIndex)
			args = append(args, *filter.CreatedBefore)
			argIndex++
		}

		if filter.ParentID != nil {
			parentUUID := utils.GetPgUUID(filter.ParentID)
			if parentUUID.Valid {
				baseQuery += fmt.Sprintf(" AND parent_id = $%d", argIndex)
				args = append(args, parentUUID)
				argIndex++
			}
		}
	}

	// Apply sorting
	orderBy := "ORDER BY name ASC" // default
	if sort != nil {
		direction := "ASC"
		if sort.Direction == model.SortDirectionDesc {
			direction = "DESC"
		}

		switch sort.Field {
		case model.FolderSortFieldName:
			orderBy = fmt.Sprintf("ORDER BY name %s", direction)
		case model.FolderSortFieldCreatedAt:
			orderBy = fmt.Sprintf("ORDER BY created_at %s", direction)
		case model.FolderSortFieldPath:
			orderBy = fmt.Sprintf("ORDER BY path %s", direction)
		}
	}

	// Get total count first
	countQuery := strings.Replace(baseQuery, "SELECT id, name, created_at, parent_id, path, real_path, owner_id", "SELECT COUNT(*)", 1)

	var totalCount int64
	err := r.DBPool.QueryRow(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	// Add pagination
	finalQuery := fmt.Sprintf("%s %s LIMIT $%d OFFSET $%d", baseQuery, orderBy, argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Execute query
	rows, err := r.DBPool.Query(ctx, finalQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var folders []*postgres.Folder
	for rows.Next() {
		var folder postgres.Folder
		err := rows.Scan(&folder.ID, &folder.Name, &folder.CreatedAt, &folder.ParentID, &folder.Path, &folder.RealPath, &folder.OwnerID)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		folders = append(folders, &folder)
	}

	return &model.FoldersResponse{
		Folders:         folders,
		TotalCount:      int32(totalCount),
		HasNextPage:     int64(offset+limit) < totalCount,
		HasPreviousPage: offset > 0,
	}, nil
}

// GetFolderDetails is the resolver for the getFolderDetails field.
func (r *queryResolver) GetFolderDetails(ctx context.Context, folderID string, publicToken *string) (*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return nil, fmt.Errorf("invalid folderId")
	}

	folder, err := r.DB.GetFolderByID(ctx, folderUUID)
	if err != nil {
		return nil, fmt.Errorf("folder not found")
	}

	canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
		ID:               folder.ID,
		PublicToken:      utils.GetPgString(publicToken),
		SharedWithUserID: userID,
	})
	if err != nil {
		return nil, fmt.Errorf("error checking folder access: %w", err)
	}

	if (folder.OwnerID != userID) && !canAccessFolder {
		return nil, fmt.Errorf("permission denied")
	}

	return &folder, nil
}

// SearchFiles is the resolver for the searchFiles field.
func (r *queryResolver) SearchFiles(ctx context.Context, query string, filter *model.FileFilter, sort *model.FileSort, pagination *model.PaginationInput, publicToken *string) (*model.FilesResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Set default pagination
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			offset = int(*pagination.Offset)
		}
	}

	// Build search query
	baseQuery := `
		SELECT f.id, f.filename, f.upload_date, pf.mime_type, pf.size_bytes
		FROM files f
		JOIN physical_files pf ON f.physical_file_id = pf.id
		WHERE f.owner_id = $1 AND f.filename ILIKE $2`

	args := []interface{}{userID, "%" + query + "%"}
	argIndex := 3

	// Apply additional filters
	if filter != nil {
		if filter.MimeType != nil {
			baseQuery += fmt.Sprintf(" AND pf.mime_type ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.MimeType+"%")
			argIndex++
		}

		if filter.MinSize != nil {
			baseQuery += fmt.Sprintf(" AND pf.size_bytes >= $%d", argIndex)
			args = append(args, *filter.MinSize)
			argIndex++
		}

		if filter.MaxSize != nil {
			baseQuery += fmt.Sprintf(" AND pf.size_bytes <= $%d", argIndex)
			args = append(args, *filter.MaxSize)
			argIndex++
		}

		if filter.UploadedAfter != nil {
			baseQuery += fmt.Sprintf(" AND f.upload_date > $%d", argIndex)
			args = append(args, *filter.UploadedAfter)
			argIndex++
		}

		if filter.UploadedBefore != nil {
			baseQuery += fmt.Sprintf(" AND f.upload_date < $%d", argIndex)
			args = append(args, *filter.UploadedBefore)
			argIndex++
		}
	}

	// Apply sorting
	orderBy := "ORDER BY f.filename ASC" // default
	if sort != nil {
		direction := "ASC"
		if sort.Direction == model.SortDirectionDesc {
			direction = "DESC"
		}

		switch sort.Field {
		case model.FileSortFieldFilename:
			orderBy = fmt.Sprintf("ORDER BY f.filename %s", direction)
		case model.FileSortFieldSize:
			orderBy = fmt.Sprintf("ORDER BY pf.size_bytes %s", direction)
		case model.FileSortFieldUploadDate:
			orderBy = fmt.Sprintf("ORDER BY f.upload_date %s", direction)
		case model.FileSortFieldMimeType:
			orderBy = fmt.Sprintf("ORDER BY pf.mime_type %s", direction)
		}
	}

	// Get total count
	countQuery := strings.Replace(baseQuery, "SELECT f.id, f.filename, f.upload_date, pf.mime_type, pf.size_bytes", "SELECT COUNT(*)", 1)

	var totalCount int64
	err := r.DBPool.QueryRow(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	// Add pagination
	finalQuery := fmt.Sprintf("%s %s LIMIT $%d OFFSET $%d", baseQuery, orderBy, argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Execute query
	rows, err := r.DBPool.Query(ctx, finalQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var fileID pgtype.UUID
		var filename string
		var uploadDate pgtype.Timestamptz
		var mimeType string
		var sizeBytes int64

		err := rows.Scan(&fileID, &filename, &uploadDate, &mimeType, &sizeBytes)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		files = append(files, &model.File{
			ID:         fileID.String(),
			Filename:   filename,
			UploadDate: uploadDate.Time,
			MimeType:   mimeType,
			Size:       int32(sizeBytes),
		})
	}

	return &model.FilesResponse{
		Files:           files,
		TotalCount:      int32(totalCount),
		HasNextPage:     int64(offset+limit) < totalCount,
		HasPreviousPage: offset > 0,
	}, nil
}

// SearchFolders is the resolver for the searchFolders field.
func (r *queryResolver) SearchFolders(ctx context.Context, query string, filter *model.FolderFilter, sort *model.FolderSort, pagination *model.PaginationInput, publicToken *string) (*model.FoldersResponse, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	// Set default pagination
	limit := 20
	offset := 0
	if pagination != nil {
		if pagination.Limit != nil {
			limit = int(*pagination.Limit)
		}
		if pagination.Offset != nil {
			offset = int(*pagination.Offset)
		}
	}

	// Build search query
	baseQuery := `
		SELECT id, name, created_at, parent_id, path, real_path, owner_id 
		FROM folders 
		WHERE owner_id = $1 AND name ILIKE $2`

	args := []interface{}{userID, "%" + query + "%"}
	argIndex := 3

	// Apply additional filters
	if filter != nil {
		if filter.Path != nil {
			baseQuery += fmt.Sprintf(" AND path::text ILIKE $%d", argIndex)
			args = append(args, "%"+*filter.Path+"%")
			argIndex++
		}

		if filter.CreatedAfter != nil {
			baseQuery += fmt.Sprintf(" AND created_at > $%d", argIndex)
			args = append(args, *filter.CreatedAfter)
			argIndex++
		}

		if filter.CreatedBefore != nil {
			baseQuery += fmt.Sprintf(" AND created_at < $%d", argIndex)
			args = append(args, *filter.CreatedBefore)
			argIndex++
		}

		if filter.ParentID != nil {
			parentUUID := utils.GetPgUUID(filter.ParentID)
			if parentUUID.Valid {
				baseQuery += fmt.Sprintf(" AND parent_id = $%d", argIndex)
				args = append(args, parentUUID)
				argIndex++
			}
		}
	}

	// Apply sorting
	orderBy := "ORDER BY name ASC" // default
	if sort != nil {
		direction := "ASC"
		if sort.Direction == model.SortDirectionDesc {
			direction = "DESC"
		}

		switch sort.Field {
		case model.FolderSortFieldName:
			orderBy = fmt.Sprintf("ORDER BY name %s", direction)
		case model.FolderSortFieldCreatedAt:
			orderBy = fmt.Sprintf("ORDER BY created_at %s", direction)
		case model.FolderSortFieldPath:
			orderBy = fmt.Sprintf("ORDER BY path %s", direction)
		}
	}

	// Get total count
	countQuery := strings.Replace(baseQuery, "SELECT id, name, created_at, parent_id, path, real_path, owner_id", "SELECT COUNT(*)", 1)

	var totalCount int64
	err := r.DBPool.QueryRow(ctx, countQuery, args...).Scan(&totalCount)
	if err != nil {
		return nil, fmt.Errorf("failed to get total count: %w", err)
	}

	// Add pagination
	finalQuery := fmt.Sprintf("%s %s LIMIT $%d OFFSET $%d", baseQuery, orderBy, argIndex, argIndex+1)
	args = append(args, limit, offset)

	// Execute query
	rows, err := r.DBPool.Query(ctx, finalQuery, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer rows.Close()

	var folders []*postgres.Folder
	for rows.Next() {
		var folder postgres.Folder
		err := rows.Scan(&folder.ID, &folder.Name, &folder.CreatedAt, &folder.ParentID, &folder.Path, &folder.RealPath, &folder.OwnerID)
		if err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		folders = append(folders, &folder)
	}

	return &model.FoldersResponse{
		Folders:         folders,
		TotalCount:      int32(totalCount),
		HasNextPage:     int64(offset+limit) < totalCount,
		HasPreviousPage: offset > 0,
	}, nil
}

// GetFilesInFolder is the resolver for the getFilesInFolder field.
func (r *queryResolver) GetFilesInFolder(ctx context.Context, folderID *string, publicToken *string) ([]*model.File, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	var files []*model.File
	if publicToken != nil && folderID == nil {
		folderIDFromDB, err := r.DB.GetFolderIdByPublicToken(ctx, utils.GetPgString(publicToken))

		if err != nil {
			return nil, fmt.Errorf("invalid public token or no access to any folder with this token")
		}

		folderUUID := uuid.UUID(folderIDFromDB.Bytes)
		folderIDStr := folderUUID.String()
		folderID = &folderIDStr
	}

	if folderID == nil && publicToken == nil {
		rootFiles, err := r.DB.ListRootFilesByOwner(ctx, userID)
		if err != nil {
			return nil, err
		}

		for _, f := range rootFiles {
			files = append(files, &model.File{
				ID:         f.ID.String(),
				Filename:   f.Filename,
				UploadDate: f.UploadDate.Time,
				Size:       int32(f.SizeBytes),
				MimeType:   f.MimeType,
			})
		}

	} else {
		folderUUID := utils.GetPgUUID(folderID)
		if !folderUUID.Valid {
			return nil, fmt.Errorf("invalid folderId")
		}

		requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)
		if err != nil {
			return nil, fmt.Errorf("folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		folderFiles, err := r.DB.ListFilesByFolder(ctx, folderUUID)
		if err != nil {
			return nil, err
		}
		for _, f := range folderFiles {
			files = append(files, &model.File{
				ID:         f.ID.String(),
				Filename:   f.Filename,
				UploadDate: f.UploadDate.Time,
				Size:       int32(f.SizeBytes),
				MimeType:   f.MimeType,
			})
		}
	}

	return files, nil
}

// GetFoldersInFolder is the resolver for the getFoldersInFolder field.
func (r *queryResolver) GetFoldersInFolder(ctx context.Context, folderID *string, publicToken *string) ([]*postgres.Folder, error) {
	userID := utils.GetUserID(ctx)
	if !userID.Valid && publicToken == nil {
		return nil, fmt.Errorf("access denied")
	}

	var folders []*postgres.Folder
	if publicToken != nil && folderID == nil {
		folderIDFromDB, err := r.DB.GetFolderIdByPublicToken(ctx, utils.GetPgString(publicToken))
		if err != nil {
			return nil, fmt.Errorf("invalid public token or no access to any folder with this token")
		}

		folderUUID := uuid.UUID(folderIDFromDB.Bytes)
		folderIDStr := folderUUID.String()
		folderID = &folderIDStr
	}

	if folderID == nil && publicToken == nil {
		rootFolders, err := r.DB.ListRootFoldersByOwner(ctx, userID)
		if err != nil {
			return nil, err
		}

		for _, f := range rootFolders {
			folders = append(folders, &postgres.Folder{
				ID:        f.ID,
				Name:      f.Name,
				CreatedAt: f.CreatedAt,
				ParentID:  f.ParentID,
				Path:      f.Path,
			})
		}

	} else {
		folderUUID := utils.GetPgUUID(folderID)
		if !folderUUID.Valid {
			return nil, fmt.Errorf("invalid folderId")
		}

		requestedFolder, err := r.DB.GetFolderByID(ctx, folderUUID)
		if err != nil {
			return nil, fmt.Errorf("folder not found")
		}

		canAccessFolder, err := r.DB.CanAccessFolder(ctx, postgres.CanAccessFolderParams{
			ID:               requestedFolder.ID,
			PublicToken:      utils.GetPgString(publicToken),
			SharedWithUserID: userID,
		})
		if err != nil {
			return nil, fmt.Errorf("error checking folder access: %w", err)
		}

		if (requestedFolder.OwnerID != userID) && !canAccessFolder {
			return nil, fmt.Errorf("permission denied")
		}

		folderFiles, err := r.DB.ListSubfoldersByParent(ctx, folderUUID)
		if err != nil {
			return nil, err
		}
		for _, f := range folderFiles {
			folders = append(folders, &postgres.Folder{
				ID:        f.ID,
				Name:      f.Name,
				CreatedAt: f.CreatedAt,
				ParentID:  f.ParentID,
				Path:      f.Path,
			})
		}
	}

	return folders, nil
}

// Folder returns generated.FolderResolver implementation.
func (r *Resolver) Folder() generated.FolderResolver { return &folderResolver{r} }

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type folderResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
