package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"

	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/generated"
	"github.com/YuanziX/files-backend/internal/utils"
)

// ShareFileWithUser is the resolver for the shareFileWithUser field.
func (r *mutationResolver) ShareFileWithUser(ctx context.Context, fileID string, userID string) (string, error) {
	currentUserID := utils.GetUserID(ctx)

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return "", fmt.Errorf("invalid file ID")
	}

	userUUID := utils.GetPgUUID(&userID)
	if !userUUID.Valid {
		return "", fmt.Errorf("invalid user ID")
	}

	// Check if the current user owns the file
	ownerCheck, err := r.DB.CheckFileOwnership(ctx, postgres.CheckFileOwnershipParams{
		ID:      fileUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to check file ownership: %w", err)
	}

	if !ownerCheck {
		return "", fmt.Errorf("you do not have permission to share this file")
	}

	err = r.DB.ShareFileWithUser(ctx, postgres.ShareFileWithUserParams{
		FileID:           fileUUID,
		OwnerID:          currentUserID,
		SharedWithUserID: userUUID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to share file with user: %w", err)
	}
	return fileID, nil
}

// UnshareFileWithUser is the resolver for the unshareFileWithUser field.
func (r *mutationResolver) UnshareFileWithUser(ctx context.Context, fileID string, userID string) (bool, error) {
	currentUserID := utils.GetUserID(ctx)

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return false, fmt.Errorf("invalid file ID")
	}

	userUUID := utils.GetPgUUID(&userID)
	if !userUUID.Valid {
		return false, fmt.Errorf("invalid user ID")
	}

	// Check if the current user owns the file
	ownerCheck, err := r.DB.CheckFileOwnership(ctx, postgres.CheckFileOwnershipParams{
		ID:      fileUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return false, fmt.Errorf("failed to check file ownership: %w", err)
	}

	if !ownerCheck {
		return false, fmt.Errorf("you do not have permission to share this file")
	}

	err = r.DB.RevokeUserShare(ctx, postgres.RevokeUserShareParams{
		OwnerID:          currentUserID,
		FileID:           fileUUID,
		SharedWithUserID: userUUID,
	})

	if err != nil {
		return false, fmt.Errorf("failed to unshare file with user: %w", err)
	}

	return true, nil
}

// ShareFolderWithUser is the resolver for the shareFolderWithUser field.
func (r *mutationResolver) ShareFolderWithUser(ctx context.Context, folderID string, userID string) (string, error) {
	currentUserID := utils.GetUserID(ctx)

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return "", fmt.Errorf("invalid folder ID")
	}

	userUUID := utils.GetPgUUID(&userID)
	if !userUUID.Valid {
		return "", fmt.Errorf("invalid user ID")
	}

	// Check if the current user owns the folder
	ownerCheck, err := r.DB.CheckFolderOwnership(ctx, postgres.CheckFolderOwnershipParams{
		ID:      folderUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to check folder ownership: %w", err)
	}

	if !ownerCheck {
		return "", fmt.Errorf("you do not have permission to share this folder")
	}

	err = r.DB.ShareFolderWithUser(ctx, postgres.ShareFolderWithUserParams{
		FolderID:         folderUUID,
		OwnerID:          currentUserID,
		SharedWithUserID: userUUID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to share folder with user: %w", err)
	}
	return folderID, nil
}

// UnshareFolderWithUser is the resolver for the unshareFolderWithUser field.
func (r *mutationResolver) UnshareFolderWithUser(ctx context.Context, folderID string, userID string) (bool, error) {
	currentUserID := utils.GetUserID(ctx)

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return false, fmt.Errorf("invalid folder ID")
	}

	userUUID := utils.GetPgUUID(&userID)
	if !userUUID.Valid {
		return false, fmt.Errorf("invalid user ID")
	}

	// Check if the current user owns the folder
	ownerCheck, err := r.DB.CheckFolderOwnership(ctx, postgres.CheckFolderOwnershipParams{
		ID:      folderUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return false, fmt.Errorf("failed to check folder ownership: %w", err)
	}

	if !ownerCheck {
		return false, fmt.Errorf("you do not have permission to share this folder")
	}

	err = r.DB.RevokeUserShare(ctx, postgres.RevokeUserShareParams{
		OwnerID:          currentUserID,
		FileID:           folderUUID,
		SharedWithUserID: userUUID,
	})

	if err != nil {
		return false, fmt.Errorf("failed to unshare folder with user: %w", err)
	}

	return true, nil
}

// ShareFilePublic is the resolver for the shareFilePublic field.
func (r *mutationResolver) ShareFilePublic(ctx context.Context, fileID string) (string, error) {
	currentUserID := utils.GetUserID(ctx)

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return "", fmt.Errorf("invalid file ID")
	}

	// Check if the current user owns the file
	ownerCheck, err := r.DB.CheckFileOwnership(ctx, postgres.CheckFileOwnershipParams{
		ID:      fileUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to check file ownership: %w", err)
	}

	if !ownerCheck {
		return "", fmt.Errorf("you do not have permission to share this file")
	}

	publicToken, err := utils.Generate32CharToken()
	if err != nil {
		return "", fmt.Errorf("failed to generate public token: %w", err)
	}

	err = r.DB.ShareFilePublicly(ctx, postgres.ShareFilePubliclyParams{
		FileID:      fileUUID,
		OwnerID:     currentUserID,
		PublicToken: utils.GetPgString(&publicToken),
	})

	if err != nil {
		return "", fmt.Errorf("failed to share file publicly: %w", err)
	}

	return publicToken, nil
}

// ShareFolderPublic is the resolver for the shareFolderPublic field.
func (r *mutationResolver) ShareFolderPublic(ctx context.Context, folderID string) (string, error) {
	currentUserID := utils.GetUserID(ctx)

	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return "", fmt.Errorf("invalid folder ID")
	}

	// Check if the current user owns the folder
	ownerCheck, err := r.DB.CheckFolderOwnership(ctx, postgres.CheckFolderOwnershipParams{
		ID:      folderUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return "", fmt.Errorf("failed to check folder ownership: %w", err)
	}

	if !ownerCheck {
		return "", fmt.Errorf("you do not have permission to share this folder")
	}

	publicToken, err := utils.Generate32CharToken()
	if err != nil {
		return "", fmt.Errorf("failed to generate public token: %w", err)
	}

	err = r.DB.ShareFolderPublicly(ctx, postgres.ShareFolderPubliclyParams{
		FolderID:    folderUUID,
		OwnerID:     currentUserID,
		PublicToken: utils.GetPgString(&publicToken),
	})

	if err != nil {
		return "", fmt.Errorf("failed to share folder publicly: %w", err)
	}

	return publicToken, nil
}

// RevokePubliclyShared is the resolver for the revokePubliclyShared field.
func (r *mutationResolver) RevokePubliclyShared(ctx context.Context, publicToken string) (bool, error) {
	currentUserID := utils.GetUserID(ctx)

	// Check if the current user owns the share
	ownerCheck, err := r.DB.CheckUserOwnsShare(ctx, postgres.CheckUserOwnsShareParams{
		PublicToken: utils.GetPgString(&publicToken),
		OwnerID:     currentUserID,
	})

	if err != nil {
		return false, fmt.Errorf("failed to check ownership: %w", err)
	}

	if !ownerCheck {
		return false, fmt.Errorf("you do not have permission over this item")
	}

	err = r.DB.RevokePublicShare(ctx, postgres.RevokePublicShareParams{
		OwnerID:     currentUserID,
		PublicToken: utils.GetPgString(&publicToken),
	})

	if err != nil {
		return false, fmt.Errorf("failed to unshare item: %w", err)
	}

	return true, nil
}

// GetFileShares is the resolver for the getFileShares field.
func (r *queryResolver) GetFileShares(ctx context.Context, fileID string) ([]*postgres.Share, error) {
	currentUserID := utils.GetUserID(ctx)

	// check user owns file
	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return nil, fmt.Errorf("invalid file ID")
	}

	ownerCheck, err := r.DB.CheckFileOwnership(ctx, postgres.CheckFileOwnershipParams{
		ID:      fileUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to check ownership: %w", err)
	}

	if !ownerCheck {
		return nil, fmt.Errorf("you do not have permission over this item")
	}

	shares, err := r.DB.GetFileShares(ctx, postgres.GetFileSharesParams{
		FileID:  fileUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get file shares: %w", err)
	}

	sharePtrs := make([]*postgres.Share, len(shares))
	for i := range shares {
		sharePtrs[i] = &shares[i]
	}
	return sharePtrs, nil
}

// GetFolderShares is the resolver for the getFolderShares field.
func (r *queryResolver) GetFolderShares(ctx context.Context, folderID string) ([]*postgres.Share, error) {
	currentUserID := utils.GetUserID(ctx)

	// check user owns folder
	folderUUID := utils.GetPgUUID(&folderID)
	if !folderUUID.Valid {
		return nil, fmt.Errorf("invalid folder ID")
	}

	ownerCheck, err := r.DB.CheckFolderOwnership(ctx, postgres.CheckFolderOwnershipParams{
		ID:      folderUUID,
		OwnerID: currentUserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to check ownership: %w", err)
	}

	if !ownerCheck {
		return nil, fmt.Errorf("you do not have permission over this item")
	}

	shares, err := r.DB.GetFolderShares(ctx, postgres.GetFolderSharesParams{
		FolderID: folderUUID,
		OwnerID:  currentUserID,
	})

	if err != nil {
		return nil, fmt.Errorf("failed to get folder shares: %w", err)
	}

	sharePtrs := make([]*postgres.Share, len(shares))
	for i := range shares {
		sharePtrs[i] = &shares[i]
	}
	return sharePtrs, nil
}

// GetMyShares is the resolver for the getMyShares field.
func (r *queryResolver) GetMyShares(ctx context.Context) ([]*postgres.Share, error) {
	currentUserID := utils.GetUserID(ctx)

	shares, err := r.DB.GetMyShares(ctx, currentUserID)
	if err != nil {
		return nil, fmt.Errorf("failed to get shares: %w", err)
	}

	sharePtrs := make([]*postgres.Share, len(shares))
	for i := range shares {
		sharePtrs[i] = &shares[i]
	}
	return sharePtrs, nil
}

// ID is the resolver for the id field.
func (r *shareResolver) ID(ctx context.Context, obj *postgres.Share) (string, error) {
	return obj.ID.String(), nil
}

// Owner is the resolver for the owner field.
func (r *shareResolver) Owner(ctx context.Context, obj *postgres.Share) (*postgres.User, error) {
	user, err := r.DB.GetUserByID(ctx, obj.OwnerID)
	return &user, err
}

// SharedWith is the resolver for the sharedWith field.
func (r *shareResolver) SharedWith(ctx context.Context, obj *postgres.Share) (*postgres.User, error) {
	if !obj.SharedWithUserID.Valid {
		// SharedWithUserID is NULL, so this is a public share
		return nil, nil
	}
	user, err := r.DB.GetUserByID(ctx, obj.SharedWithUserID)
	return &user, err
}

// ShareType is the resolver for the shareType field.
func (r *shareResolver) ShareType(ctx context.Context, obj *postgres.Share) (string, error) {
	return string(obj.ShareType), nil
}

// PublicToken is the resolver for the publicToken field.
func (r *shareResolver) PublicToken(ctx context.Context, obj *postgres.Share) (*string, error) {
	return &obj.PublicToken.String, nil
}

// CreatedAt is the resolver for the createdAt field.
func (r *shareResolver) CreatedAt(ctx context.Context, obj *postgres.Share) (string, error) {
	return obj.CreatedAt.Time.Format("2006-01-02T15:04:05Z07:00"), nil
}

// Share returns generated.ShareResolver implementation.
func (r *Resolver) Share() generated.ShareResolver { return &shareResolver{r} }

type shareResolver struct{ *Resolver }
