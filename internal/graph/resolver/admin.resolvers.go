package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"time"

	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/generated"
	"github.com/YuanziX/files-backend/internal/graph/model"
	"github.com/YuanziX/files-backend/internal/utils"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"golang.org/x/crypto/bcrypt"
)

// CreateAdminUser is the resolver for the createAdminUser field.
func (r *mutationResolver) CreateAdminUser(ctx context.Context, email string, password string) (string, error) {
	// hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}

	admin, err := r.DB.CreateAdmin(ctx, postgres.CreateAdminParams{
		Name:         "Test Admin",
		Email:        email,
		PasswordHash: string(hashedPassword),
	})

	if err != nil {
		return "", fmt.Errorf("failed to create admin user: %w", err)
	}

	return admin.ID.String(), nil
}

// GetFiles is the resolver for the getFiles field.
func (r *queryResolver) GetFiles(ctx context.Context, folderID string, limit int32, pageNo int32) (*model.GetFilesResponse, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	files, err := r.DB.GetAllFilesForAdmin(ctx, postgres.GetAllFilesForAdminParams{
		Limit:  limit,
		Offset: (pageNo - 1) * limit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %v", err)
	}

	totalCount, err := r.DB.CountAllFilesForAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count files: %v", err)
	}

	var fileModels []*model.AdminFile
	for _, file := range files {
		fileModels = append(fileModels, &model.AdminFile{
			ID:            file.ID.String(),
			Filename:      file.Filename,
			MimeType:      file.MimeType,
			Size:          int32(file.SizeBytes),
			DownloadCount: int32(file.DownloadCount),
			OwnerID:       file.OwnerID.String(),
			UploadDate:    file.UploadDate.Time,
		})
	}

	return &model.GetFilesResponse{
		Files: fileModels,
		Pagination: &model.Pagination{
			Count:      int32(len(fileModels)),
			TotalCount: int32(totalCount),
			PageNo:     pageNo,
			TotalPages: (int32(totalCount) + limit - 1) / limit,
			Limit:      limit,
		},
	}, nil
}

// DownloadFile is the resolver for the downloadFile field.
func (r *queryResolver) DownloadFile(ctx context.Context, fileID string) (*model.DownloadFileResponse, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	file, err := r.DB.GetFileForDownload(ctx, utils.GetPgUUID(&fileID))
	if err != nil {
		return nil, fmt.Errorf("failed to get file for download: %v", err)
	}

	expiry := 10 * time.Minute
	objectKey := file.ContentHash

	req, err := r.S3PresignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket:                     &r.Cfg.S3BucketName,
		Key:                        &objectKey,
		ResponseContentDisposition: aws.String(fmt.Sprintf(`attachment; filename="%s"`, file.Filename)),
	}, s3.WithPresignExpires(expiry))
	if err != nil {
		return nil, fmt.Errorf("could not generate download URL: %w", err)
	}

	return &model.DownloadFileResponse{
		URL:      req.URL,
		Filename: file.Filename,
	}, nil
}

// GetUserByID is the resolver for the getUserByID field.
func (r *queryResolver) GetUserByID(ctx context.Context, userID string) (*postgres.User, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	user, err := r.DB.GetUserByID(ctx, utils.GetPgUUID(&userID))
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	return &user, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
