package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"time"

	"github.com/YuanziX/files-backend/internal/database/postgres"
	"github.com/YuanziX/files-backend/internal/graph/generated"
	"github.com/YuanziX/files-backend/internal/graph/model"
	"github.com/YuanziX/files-backend/internal/utils"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/s3"
	"golang.org/x/crypto/bcrypt"
)

// CreateAdminUser is the resolver for the createAdminUser field.
func (r *mutationResolver) CreateAdminUser(ctx context.Context, email string, password string) (string, error) {
	// hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return "", fmt.Errorf("failed to hash password: %w", err)
	}

	admin, err := r.DB.CreateAdmin(ctx, postgres.CreateAdminParams{
		Name:         "Test Admin",
		Email:        email,
		PasswordHash: string(hashedPassword),
	})

	if err != nil {
		return "", fmt.Errorf("failed to create admin user: %w", err)
	}

	return admin.ID.String(), nil
}

// GetFiles is the resolver for the getFiles field.
func (r *queryResolver) GetFiles(ctx context.Context, search *string, limit *int32, pageNo *int32) (*model.GetFilesResponse, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	var useLimit, usePageNo int32 = 10, 1

	if limit != nil && *limit > 0 {
		useLimit = *limit
	}
	if pageNo != nil && *pageNo > 0 {
		usePageNo = *pageNo
	}

	var searchStr string
	if search == nil {
		searchStr = ""
	}

	files, err := r.DB.GetAllFilesForAdmin(ctx, postgres.GetAllFilesForAdminParams{
		Limit:   useLimit,
		Offset:  (usePageNo - 1) * useLimit,
		Column3: utils.GetPgString(&searchStr),
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get files: %v", err)
	}

	totalCount, err := r.DB.CountAllFilesForAdmin(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count files: %v", err)
	}

	var fileModels []*model.AdminFile
	for _, file := range files {
		fileModels = append(fileModels, &model.AdminFile{
			ID:            file.ID.String(),
			Filename:      file.Filename,
			MimeType:      file.MimeType,
			Size:          int32(file.SizeBytes),
			DownloadCount: int32(file.DownloadCount),
			OwnerID:       file.OwnerID.String(),
			UploadDate:    file.UploadDate.Time,
		})
	}

	return &model.GetFilesResponse{
		Files: fileModels,
		Pagination: &model.Pagination{
			Count:      int32(len(fileModels)),
			TotalCount: int32(totalCount),
			PageNo:     usePageNo,
			TotalPages: (int32(totalCount) + useLimit - 1) / useLimit,
			Limit:      useLimit,
		},
	}, nil
}

// DownloadFile is the resolver for the downloadFile field.
func (r *queryResolver) DownloadFile(ctx context.Context, fileID string) (*model.DownloadFileResponse, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	fileUUID := utils.GetPgUUID(&fileID)
	if !fileUUID.Valid {
		return nil, fmt.Errorf("invalid fileId")
	}

	file, err := r.DB.GetFileForDownload(ctx, fileUUID)
	if err != nil {
		return nil, fmt.Errorf("failed to get file for download: %v", err)
	}

	expiry := 10 * time.Minute
	objectKey := file.ContentHash

	req, err := r.S3PresignClient.PresignGetObject(ctx, &s3.GetObjectInput{
		Bucket:                     &r.Cfg.S3BucketName,
		Key:                        &objectKey,
		ResponseContentDisposition: aws.String(fmt.Sprintf(`attachment; filename="%s"`, file.Filename)),
	}, s3.WithPresignExpires(expiry))
	if err != nil {
		return nil, fmt.Errorf("could not generate download URL: %w", err)
	}

	r.DB.IncrementFileDownloadCount(ctx, fileUUID) // ignore error

	return &model.DownloadFileResponse{
		URL:      req.URL,
		Filename: file.Filename,
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, limit *int32, pageNo *int32) (*model.GetUsersResponse, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}

	useLimit, usePageNo := int32(10), int32(1)
	if limit != nil && *limit > 0 {
		useLimit = *limit
	}
	if pageNo != nil && *pageNo > 0 {
		usePageNo = *pageNo
	}

	users, err := r.DB.GetUsers(ctx, postgres.GetUsersParams{
		Limit:  useLimit,
		Offset: (usePageNo - 1) * useLimit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get users: %v", err)
	}

	totalCount, err := r.DB.CountUsers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to count users: %v", err)
	}

	var userPtrs []*postgres.User
	for i := range users {
		userPtrs = append(userPtrs, &users[i])
	}
	return &model.GetUsersResponse{
		Users: userPtrs,
		Pagination: &model.Pagination{
			Count:      int32(len(users)),
			TotalCount: int32(totalCount),
			PageNo:     usePageNo,
			TotalPages: (int32(totalCount) + useLimit - 1) / useLimit,
			Limit:      useLimit,
		},
	}, nil
}

// GetUserByID is the resolver for the getUserByID field.
func (r *queryResolver) GetUserByID(ctx context.Context, userID string) (*postgres.User, error) {
	adminId := utils.GetUserID(ctx)
	if !adminId.Valid {
		return nil, fmt.Errorf("access denied: you must be logged in")
	}
	if role, ok := utils.GetRole(ctx); !ok || role != "admin" {
		return nil, fmt.Errorf("access denied: you must be an admin")
	}

	user, err := r.DB.GetUserByID(ctx, utils.GetPgUUID(&userID))
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %v", err)
	}

	return &user, nil
}

// GetUsageStatsByUser is the resolver for the getUsageStatsByUser field.
func (r *queryResolver) GetUsageStatsByUser(ctx context.Context, userID string) (*model.UsageStat, error) {
	usageStats, err := r.DB.GetUserUsageStats(ctx, utils.GetPgUUID(&userID))
	if err != nil {
		return nil, fmt.Errorf("failed to get usage stats: %v", err)
	}

	return &model.UsageStat{
		TotalStorageUsed:  utils.GetIntFromPgNumeric(usageStats.TotalStorageUsed),
		ActualStorageUsed: utils.GetIntFromPgNumeric(usageStats.ActualStorageUsed),
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
