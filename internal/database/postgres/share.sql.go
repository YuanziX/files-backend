// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: share.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkUserOwnsShare = `-- name: CheckUserOwnsShare :one
SELECT EXISTS (
    SELECT 1 FROM shares
    WHERE public_token = $1 AND owner_id = $2
)
`

type CheckUserOwnsShareParams struct {
	PublicToken pgtype.Text `json:"public_token"`
	OwnerID     pgtype.UUID `json:"owner_id"`
}

func (q *Queries) CheckUserOwnsShare(ctx context.Context, arg CheckUserOwnsShareParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserOwnsShare, arg.PublicToken, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getFileShares = `-- name: GetFileShares :many
SELECT id, file_id, folder_id, share_type, owner_id, shared_with_user_id, public_token, download_count, created_at FROM shares
WHERE file_id = $1
  AND owner_id = $2
`

type GetFileSharesParams struct {
	FileID  pgtype.UUID `json:"file_id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) GetFileShares(ctx context.Context, arg GetFileSharesParams) ([]Share, error) {
	rows, err := q.db.Query(ctx, getFileShares, arg.FileID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Share
	for rows.Next() {
		var i Share
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.FolderID,
			&i.ShareType,
			&i.OwnerID,
			&i.SharedWithUserID,
			&i.PublicToken,
			&i.DownloadCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFolderIdByPublicToken = `-- name: GetFolderIdByPublicToken :one
SELECT folder_id FROM shares
WHERE public_token = $1
  AND share_type = 'public'
`

func (q *Queries) GetFolderIdByPublicToken(ctx context.Context, publicToken pgtype.Text) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getFolderIdByPublicToken, publicToken)
	var folder_id pgtype.UUID
	err := row.Scan(&folder_id)
	return folder_id, err
}

const getFolderShares = `-- name: GetFolderShares :many
SELECT id, file_id, folder_id, share_type, owner_id, shared_with_user_id, public_token, download_count, created_at FROM shares
WHERE folder_id = $1
  AND owner_id = $2
`

type GetFolderSharesParams struct {
	FolderID pgtype.UUID `json:"folder_id"`
	OwnerID  pgtype.UUID `json:"owner_id"`
}

func (q *Queries) GetFolderShares(ctx context.Context, arg GetFolderSharesParams) ([]Share, error) {
	rows, err := q.db.Query(ctx, getFolderShares, arg.FolderID, arg.OwnerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Share
	for rows.Next() {
		var i Share
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.FolderID,
			&i.ShareType,
			&i.OwnerID,
			&i.SharedWithUserID,
			&i.PublicToken,
			&i.DownloadCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyShares = `-- name: GetMyShares :many
SELECT id, file_id, folder_id, share_type, owner_id, shared_with_user_id, public_token, download_count, created_at FROM shares
WHERE owner_id = $1
`

func (q *Queries) GetMyShares(ctx context.Context, ownerID pgtype.UUID) ([]Share, error) {
	rows, err := q.db.Query(ctx, getMyShares, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Share
	for rows.Next() {
		var i Share
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.FolderID,
			&i.ShareType,
			&i.OwnerID,
			&i.SharedWithUserID,
			&i.PublicToken,
			&i.DownloadCount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokePublicShare = `-- name: RevokePublicShare :exec
DELETE FROM shares
WHERE owner_id = $1
  AND public_token = $2
  AND share_type = 'public'
`

type RevokePublicShareParams struct {
	OwnerID     pgtype.UUID `json:"owner_id"`
	PublicToken pgtype.Text `json:"public_token"`
}

func (q *Queries) RevokePublicShare(ctx context.Context, arg RevokePublicShareParams) error {
	_, err := q.db.Exec(ctx, revokePublicShare, arg.OwnerID, arg.PublicToken)
	return err
}

const revokeUserShare = `-- name: RevokeUserShare :exec
DELETE FROM shares
WHERE owner_id = $1
  AND (
    (file_id = $2 AND folder_id IS NULL)
    OR (folder_id = $2 AND file_id IS NULL)
  )
  AND shared_with_user_id = $3
  AND share_type = 'user'
`

type RevokeUserShareParams struct {
	OwnerID          pgtype.UUID `json:"owner_id"`
	FileID           pgtype.UUID `json:"file_id"`
	SharedWithUserID pgtype.UUID `json:"shared_with_user_id"`
}

func (q *Queries) RevokeUserShare(ctx context.Context, arg RevokeUserShareParams) error {
	_, err := q.db.Exec(ctx, revokeUserShare, arg.OwnerID, arg.FileID, arg.SharedWithUserID)
	return err
}

const shareFilePublicly = `-- name: ShareFilePublicly :exec
INSERT INTO shares (file_id, folder_id, owner_id, public_token, share_type)
VALUES ($1, NULL, $2, $3, 'public')
`

type ShareFilePubliclyParams struct {
	FileID      pgtype.UUID `json:"file_id"`
	OwnerID     pgtype.UUID `json:"owner_id"`
	PublicToken pgtype.Text `json:"public_token"`
}

func (q *Queries) ShareFilePublicly(ctx context.Context, arg ShareFilePubliclyParams) error {
	_, err := q.db.Exec(ctx, shareFilePublicly, arg.FileID, arg.OwnerID, arg.PublicToken)
	return err
}

const shareFileWithUser = `-- name: ShareFileWithUser :exec
INSERT INTO shares (file_id, folder_id, owner_id, shared_with_user_id, share_type)
VALUES ($1, NULL, $2, $3, 'user')
`

type ShareFileWithUserParams struct {
	FileID           pgtype.UUID `json:"file_id"`
	OwnerID          pgtype.UUID `json:"owner_id"`
	SharedWithUserID pgtype.UUID `json:"shared_with_user_id"`
}

func (q *Queries) ShareFileWithUser(ctx context.Context, arg ShareFileWithUserParams) error {
	_, err := q.db.Exec(ctx, shareFileWithUser, arg.FileID, arg.OwnerID, arg.SharedWithUserID)
	return err
}

const shareFolderPublicly = `-- name: ShareFolderPublicly :exec
INSERT INTO shares (file_id, folder_id, owner_id, public_token, share_type)
VALUES (NULL, $1, $2, $3, 'public')
`

type ShareFolderPubliclyParams struct {
	FolderID    pgtype.UUID `json:"folder_id"`
	OwnerID     pgtype.UUID `json:"owner_id"`
	PublicToken pgtype.Text `json:"public_token"`
}

func (q *Queries) ShareFolderPublicly(ctx context.Context, arg ShareFolderPubliclyParams) error {
	_, err := q.db.Exec(ctx, shareFolderPublicly, arg.FolderID, arg.OwnerID, arg.PublicToken)
	return err
}

const shareFolderWithUser = `-- name: ShareFolderWithUser :exec
INSERT INTO shares (file_id, folder_id, owner_id, shared_with_user_id, share_type)
VALUES (NULL, $1, $2, $3, 'user')
`

type ShareFolderWithUserParams struct {
	FolderID         pgtype.UUID `json:"folder_id"`
	OwnerID          pgtype.UUID `json:"owner_id"`
	SharedWithUserID pgtype.UUID `json:"shared_with_user_id"`
}

func (q *Queries) ShareFolderWithUser(ctx context.Context, arg ShareFolderWithUserParams) error {
	_, err := q.db.Exec(ctx, shareFolderWithUser, arg.FolderID, arg.OwnerID, arg.SharedWithUserID)
	return err
}
