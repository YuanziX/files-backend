// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folder_with_sf.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listRootFoldersByOwnerWithSortAndFilter = `-- name: ListRootFoldersByOwnerWithSortAndFilter :many
SELECT 
    id,
    name,
    created_at,
    parent_id,
    path,
    owner_id
FROM folders
WHERE 
    owner_id = $1
    AND parent_id IS NULL
    AND ($2::text IS NULL OR name ILIKE '%' || $2 || '%')
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY
    CASE WHEN $5::text = 'NAME' AND $6::text = 'ASC' THEN name END ASC,
    CASE WHEN $5::text = 'NAME' AND $6::text = 'DESC' THEN name END DESC,
    CASE WHEN $5::text = 'CREATED_AT' AND $6::text = 'ASC' THEN created_at END ASC,
    CASE WHEN $5::text = 'CREATED_AT' AND $6::text = 'DESC' THEN created_at END DESC,
    name ASC
`

type ListRootFoldersByOwnerWithSortAndFilterParams struct {
	OwnerID       pgtype.UUID        `json:"owner_id"`
	NameFilter    pgtype.Text        `json:"name_filter"`
	CreatedAfter  pgtype.Timestamptz `json:"created_after"`
	CreatedBefore pgtype.Timestamptz `json:"created_before"`
	SortField     pgtype.Text        `json:"sort_field"`
	SortOrder     pgtype.Text        `json:"sort_order"`
}

type ListRootFoldersByOwnerWithSortAndFilterRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ParentID  pgtype.UUID        `json:"parent_id"`
	Path      string             `json:"path"`
	OwnerID   pgtype.UUID        `json:"owner_id"`
}

func (q *Queries) ListRootFoldersByOwnerWithSortAndFilter(ctx context.Context, arg ListRootFoldersByOwnerWithSortAndFilterParams) ([]ListRootFoldersByOwnerWithSortAndFilterRow, error) {
	rows, err := q.db.Query(ctx, listRootFoldersByOwnerWithSortAndFilter,
		arg.OwnerID,
		arg.NameFilter,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRootFoldersByOwnerWithSortAndFilterRow
	for rows.Next() {
		var i ListRootFoldersByOwnerWithSortAndFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.ParentID,
			&i.Path,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubfoldersByParentWithSortAndFilter = `-- name: ListSubfoldersByParentWithSortAndFilter :many
SELECT 
    id,
    name,
    created_at,
    parent_id,
    path,
    owner_id
FROM folders
WHERE 
    parent_id = $1::uuid
    AND ($2::text IS NULL OR name ILIKE '%' || $2 || '%')
    AND ($3::timestamptz IS NULL OR created_at >= $3)
    AND ($4::timestamptz IS NULL OR created_at <= $4)
ORDER BY
    CASE WHEN $5::text = 'NAME' AND $6::text = 'ASC' THEN name END ASC,
    CASE WHEN $5::text = 'NAME' AND $6::text = 'DESC' THEN name END DESC,
    CASE WHEN $5::text = 'CREATED_AT' AND $6::text = 'ASC' THEN created_at END ASC,
    CASE WHEN $5::text = 'CREATED_AT' AND $6::text = 'DESC' THEN created_at END DESC,
    name ASC
`

type ListSubfoldersByParentWithSortAndFilterParams struct {
	ParentID      pgtype.UUID        `json:"parent_id"`
	NameFilter    pgtype.Text        `json:"name_filter"`
	CreatedAfter  pgtype.Timestamptz `json:"created_after"`
	CreatedBefore pgtype.Timestamptz `json:"created_before"`
	SortField     pgtype.Text        `json:"sort_field"`
	SortOrder     pgtype.Text        `json:"sort_order"`
}

type ListSubfoldersByParentWithSortAndFilterRow struct {
	ID        pgtype.UUID        `json:"id"`
	Name      string             `json:"name"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ParentID  pgtype.UUID        `json:"parent_id"`
	Path      string             `json:"path"`
	OwnerID   pgtype.UUID        `json:"owner_id"`
}

func (q *Queries) ListSubfoldersByParentWithSortAndFilter(ctx context.Context, arg ListSubfoldersByParentWithSortAndFilterParams) ([]ListSubfoldersByParentWithSortAndFilterRow, error) {
	rows, err := q.db.Query(ctx, listSubfoldersByParentWithSortAndFilter,
		arg.ParentID,
		arg.NameFilter,
		arg.CreatedAfter,
		arg.CreatedBefore,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListSubfoldersByParentWithSortAndFilterRow
	for rows.Next() {
		var i ListSubfoldersByParentWithSortAndFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.CreatedAt,
			&i.ParentID,
			&i.Path,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
