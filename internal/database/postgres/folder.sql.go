// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: folder.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const canAccessFolder = `-- name: CanAccessFolder :one
SELECT EXISTS (
    SELECT 1
    FROM shares s
    JOIN folders f ON f.id = $1
    JOIN folders sf ON sf.id = s.folder_id
    WHERE f.path <@ sf.path
      AND (
        (s.share_type = 'public' AND s.public_token = $2)
        OR
        (s.share_type = 'user' AND s.shared_with_user_id = $3)
      )
)
`

type CanAccessFolderParams struct {
	ID               pgtype.UUID `json:"id"`
	PublicToken      pgtype.Text `json:"public_token"`
	SharedWithUserID pgtype.UUID `json:"shared_with_user_id"`
}

func (q *Queries) CanAccessFolder(ctx context.Context, arg CanAccessFolderParams) (bool, error) {
	row := q.db.QueryRow(ctx, canAccessFolder, arg.ID, arg.PublicToken, arg.SharedWithUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkFolderOwnership = `-- name: CheckFolderOwnership :one
SELECT EXISTS (
    SELECT 1
    FROM folders
    WHERE id = $1 AND owner_id = $2
)
`

type CheckFolderOwnershipParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) CheckFolderOwnership(ctx context.Context, arg CheckFolderOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkFolderOwnership, arg.ID, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFolder = `-- name: CreateFolder :one
INSERT INTO folders (id, owner_id, parent_id, name, path, real_path)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, owner_id, parent_id, name, path, created_at, real_path
`

type CreateFolderParams struct {
	ID       pgtype.UUID `json:"id"`
	OwnerID  pgtype.UUID `json:"owner_id"`
	ParentID pgtype.UUID `json:"parent_id"`
	Name     string      `json:"name"`
	Path     string      `json:"path"`
	RealPath string      `json:"real_path"`
}

func (q *Queries) CreateFolder(ctx context.Context, arg CreateFolderParams) (Folder, error) {
	row := q.db.QueryRow(ctx, createFolder,
		arg.ID,
		arg.OwnerID,
		arg.ParentID,
		arg.Name,
		arg.Path,
		arg.RealPath,
	)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.RealPath,
	)
	return i, err
}

const decrementPhysicalFileRefsInFolder = `-- name: DecrementPhysicalFileRefsInFolder :exec
UPDATE physical_files pf
SET reference_count = reference_count - 1
WHERE pf.id IN (
    SELECT f.physical_file_id
    FROM files f
    JOIN folders fo ON fo.id = f.folder_id
    WHERE fo.path <@ (SELECT target.path FROM folders target WHERE target.id = $1)
)
`

func (q *Queries) DecrementPhysicalFileRefsInFolder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, decrementPhysicalFileRefsInFolder, id)
	return err
}

const deleteFilesInFolder = `-- name: DeleteFilesInFolder :exec
DELETE FROM files f
WHERE f.folder_id IN (
    SELECT fo.id
    FROM folders fo
    WHERE fo.path <@ (SELECT target.path FROM folders target WHERE target.id = $1)
)
`

func (q *Queries) DeleteFilesInFolder(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFilesInFolder, id)
	return err
}

const deleteFolder = `-- name: DeleteFolder :exec
DELETE FROM folders
WHERE id = $1 AND owner_id = $2
`

type DeleteFolderParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) DeleteFolder(ctx context.Context, arg DeleteFolderParams) error {
	_, err := q.db.Exec(ctx, deleteFolder, arg.ID, arg.OwnerID)
	return err
}

const deleteFoldersRecursively = `-- name: DeleteFoldersRecursively :exec
DELETE FROM folders fo
WHERE fo.path <@ (SELECT target.path FROM folders target WHERE target.id = $1)
`

func (q *Queries) DeleteFoldersRecursively(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFoldersRecursively, id)
	return err
}

const getFolderByID = `-- name: GetFolderByID :one
SELECT id, owner_id, parent_id, name, path, created_at, real_path FROM folders
WHERE id = $1
`

func (q *Queries) GetFolderByID(ctx context.Context, id pgtype.UUID) (Folder, error) {
	row := q.db.QueryRow(ctx, getFolderByID, id)
	var i Folder
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.ParentID,
		&i.Name,
		&i.Path,
		&i.CreatedAt,
		&i.RealPath,
	)
	return i, err
}

const getFolderPath = `-- name: GetFolderPath :one
SELECT path, real_path FROM folders WHERE id = $1 AND owner_id = $2
`

type GetFolderPathParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

type GetFolderPathRow struct {
	Path     string `json:"path"`
	RealPath string `json:"real_path"`
}

func (q *Queries) GetFolderPath(ctx context.Context, arg GetFolderPathParams) (GetFolderPathRow, error) {
	row := q.db.QueryRow(ctx, getFolderPath, arg.ID, arg.OwnerID)
	var i GetFolderPathRow
	err := row.Scan(&i.Path, &i.RealPath)
	return i, err
}

const listRootFoldersByOwner = `-- name: ListRootFoldersByOwner :many
SELECT id, owner_id, parent_id, name, path, created_at, real_path FROM folders
WHERE owner_id = $1 AND parent_id IS NULL
ORDER BY name
`

func (q *Queries) ListRootFoldersByOwner(ctx context.Context, ownerID pgtype.UUID) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listRootFoldersByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Folder
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.ParentID,
			&i.Name,
			&i.Path,
			&i.CreatedAt,
			&i.RealPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubfoldersByParent = `-- name: ListSubfoldersByParent :many
SELECT id, owner_id, parent_id, name, path, created_at, real_path FROM folders
WHERE owner_id = $1 AND parent_id = $2
ORDER BY name
`

type ListSubfoldersByParentParams struct {
	OwnerID  pgtype.UUID `json:"owner_id"`
	ParentID pgtype.UUID `json:"parent_id"`
}

func (q *Queries) ListSubfoldersByParent(ctx context.Context, arg ListSubfoldersByParentParams) ([]Folder, error) {
	rows, err := q.db.Query(ctx, listSubfoldersByParent, arg.OwnerID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Folder
	for rows.Next() {
		var i Folder
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.ParentID,
			&i.Name,
			&i.Path,
			&i.CreatedAt,
			&i.RealPath,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
