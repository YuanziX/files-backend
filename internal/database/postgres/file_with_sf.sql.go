// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file_with_sf.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listFilesByFolderWithSortAndFilter = `-- name: ListFilesByFolderWithSortAndFilter :many
SELECT 
    f.id,
    f.filename,
    f.upload_date,
    pf.size_bytes,
    pf.mime_type,
    f.owner_id,
    f.physical_file_id,
    f.folder_id
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE 
    f.folder_id = $1::uuid
    AND ($2::text IS NULL OR f.filename ILIKE '%' || $2 || '%')
    AND ($3::text IS NULL OR pf.mime_type ILIKE '%' || $3 || '%')
    AND ($4::bigint IS NULL OR pf.size_bytes >= $4)
    AND ($5::bigint IS NULL OR pf.size_bytes <= $5)
    AND ($6::timestamptz IS NULL OR f.upload_date >= $6)
    AND ($7::timestamptz IS NULL OR f.upload_date <= $7)
ORDER BY
    CASE WHEN $8::text = 'FILENAME' AND $9::text = 'ASC' THEN f.filename END ASC,
    CASE WHEN $8::text = 'FILENAME' AND $9::text = 'DESC' THEN f.filename END DESC,
    CASE WHEN $8::text = 'SIZE' AND $9::text = 'ASC' THEN pf.size_bytes END ASC,
    CASE WHEN $8::text = 'SIZE' AND $9::text = 'DESC' THEN pf.size_bytes END DESC,
    CASE WHEN $8::text = 'UPLOAD_DATE' AND $9::text = 'ASC' THEN f.upload_date END ASC,
    CASE WHEN $8::text = 'UPLOAD_DATE' AND $9::text = 'DESC' THEN f.upload_date END DESC,
    CASE WHEN $8::text = 'MIME_TYPE' AND $9::text = 'ASC' THEN pf.mime_type END ASC,
    CASE WHEN $8::text = 'MIME_TYPE' AND $9::text = 'DESC' THEN pf.mime_type END DESC,
    f.filename ASC
`

type ListFilesByFolderWithSortAndFilterParams struct {
	FolderID       pgtype.UUID        `json:"folder_id"`
	FilenameFilter pgtype.Text        `json:"filename_filter"`
	MimeTypeFilter pgtype.Text        `json:"mime_type_filter"`
	MinSize        pgtype.Int8        `json:"min_size"`
	MaxSize        pgtype.Int8        `json:"max_size"`
	UploadedAfter  pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore pgtype.Timestamptz `json:"uploaded_before"`
	SortField      pgtype.Text        `json:"sort_field"`
	SortOrder      pgtype.Text        `json:"sort_order"`
}

type ListFilesByFolderWithSortAndFilterRow struct {
	ID             pgtype.UUID        `json:"id"`
	Filename       string             `json:"filename"`
	UploadDate     pgtype.Timestamptz `json:"upload_date"`
	SizeBytes      int64              `json:"size_bytes"`
	MimeType       string             `json:"mime_type"`
	OwnerID        pgtype.UUID        `json:"owner_id"`
	PhysicalFileID pgtype.UUID        `json:"physical_file_id"`
	FolderID       pgtype.UUID        `json:"folder_id"`
}

func (q *Queries) ListFilesByFolderWithSortAndFilter(ctx context.Context, arg ListFilesByFolderWithSortAndFilterParams) ([]ListFilesByFolderWithSortAndFilterRow, error) {
	rows, err := q.db.Query(ctx, listFilesByFolderWithSortAndFilter,
		arg.FolderID,
		arg.FilenameFilter,
		arg.MimeTypeFilter,
		arg.MinSize,
		arg.MaxSize,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesByFolderWithSortAndFilterRow
	for rows.Next() {
		var i ListFilesByFolderWithSortAndFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.UploadDate,
			&i.SizeBytes,
			&i.MimeType,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFilesByOwnerWithSortAndFilter = `-- name: ListRootFilesByOwnerWithSortAndFilter :many
SELECT 
    f.id,
    f.filename,
    f.upload_date,
    pf.size_bytes,
    pf.mime_type,
    f.owner_id,
    f.physical_file_id,
    f.folder_id
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE 
    f.owner_id = $1
    AND f.folder_id IS NULL
    AND ($2::text IS NULL OR f.filename ILIKE '%' || $2 || '%')
    AND ($3::text IS NULL OR pf.mime_type ILIKE '%' || $3 || '%')
    AND ($4::bigint IS NULL OR pf.size_bytes >= $4)
    AND ($5::bigint IS NULL OR pf.size_bytes <= $5)
    AND ($6::timestamptz IS NULL OR f.upload_date >= $6)
    AND ($7::timestamptz IS NULL OR f.upload_date <= $7)
ORDER BY
    CASE WHEN $8::text = 'FILENAME' AND $9::text = 'ASC' THEN f.filename END ASC,
    CASE WHEN $8::text = 'FILENAME' AND $9::text = 'DESC' THEN f.filename END DESC,
    CASE WHEN $8::text = 'SIZE' AND $9::text = 'ASC' THEN pf.size_bytes END ASC,
    CASE WHEN $8::text = 'SIZE' AND $9::text = 'DESC' THEN pf.size_bytes END DESC,
    CASE WHEN $8::text = 'UPLOAD_DATE' AND $9::text = 'ASC' THEN f.upload_date END ASC,
    CASE WHEN $8::text = 'UPLOAD_DATE' AND $9::text = 'DESC' THEN f.upload_date END DESC,
    CASE WHEN $8::text = 'MIME_TYPE' AND $9::text = 'ASC' THEN pf.mime_type END ASC,
    CASE WHEN $8::text = 'MIME_TYPE' AND $9::text = 'DESC' THEN pf.mime_type END DESC,
    f.filename ASC
`

type ListRootFilesByOwnerWithSortAndFilterParams struct {
	OwnerID        pgtype.UUID        `json:"owner_id"`
	FilenameFilter pgtype.Text        `json:"filename_filter"`
	MimeTypeFilter pgtype.Text        `json:"mime_type_filter"`
	MinSize        pgtype.Int8        `json:"min_size"`
	MaxSize        pgtype.Int8        `json:"max_size"`
	UploadedAfter  pgtype.Timestamptz `json:"uploaded_after"`
	UploadedBefore pgtype.Timestamptz `json:"uploaded_before"`
	SortField      pgtype.Text        `json:"sort_field"`
	SortOrder      pgtype.Text        `json:"sort_order"`
}

type ListRootFilesByOwnerWithSortAndFilterRow struct {
	ID             pgtype.UUID        `json:"id"`
	Filename       string             `json:"filename"`
	UploadDate     pgtype.Timestamptz `json:"upload_date"`
	SizeBytes      int64              `json:"size_bytes"`
	MimeType       string             `json:"mime_type"`
	OwnerID        pgtype.UUID        `json:"owner_id"`
	PhysicalFileID pgtype.UUID        `json:"physical_file_id"`
	FolderID       pgtype.UUID        `json:"folder_id"`
}

func (q *Queries) ListRootFilesByOwnerWithSortAndFilter(ctx context.Context, arg ListRootFilesByOwnerWithSortAndFilterParams) ([]ListRootFilesByOwnerWithSortAndFilterRow, error) {
	rows, err := q.db.Query(ctx, listRootFilesByOwnerWithSortAndFilter,
		arg.OwnerID,
		arg.FilenameFilter,
		arg.MimeTypeFilter,
		arg.MinSize,
		arg.MaxSize,
		arg.UploadedAfter,
		arg.UploadedBefore,
		arg.SortField,
		arg.SortOrder,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRootFilesByOwnerWithSortAndFilterRow
	for rows.Next() {
		var i ListRootFilesByOwnerWithSortAndFilterRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.UploadDate,
			&i.SizeBytes,
			&i.MimeType,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAllFilesByOwner = `-- name: SearchAllFilesByOwner :many
SELECT 
    f.id,
    f.filename,
    f.upload_date,
    pf.size_bytes,
    pf.mime_type,
    f.owner_id,
    f.physical_file_id,
    f.folder_id
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE 
    f.owner_id = $1
    AND (f.filename ILIKE '%' || $2 || '%'
         OR pf.mime_type ILIKE '%' || $2 || '%')
ORDER BY f.upload_date DESC, f.filename ASC
`

type SearchAllFilesByOwnerParams struct {
	OwnerID pgtype.UUID `json:"owner_id"`
	Column2 pgtype.Text `json:"column_2"`
}

type SearchAllFilesByOwnerRow struct {
	ID             pgtype.UUID        `json:"id"`
	Filename       string             `json:"filename"`
	UploadDate     pgtype.Timestamptz `json:"upload_date"`
	SizeBytes      int64              `json:"size_bytes"`
	MimeType       string             `json:"mime_type"`
	OwnerID        pgtype.UUID        `json:"owner_id"`
	PhysicalFileID pgtype.UUID        `json:"physical_file_id"`
	FolderID       pgtype.UUID        `json:"folder_id"`
}

func (q *Queries) SearchAllFilesByOwner(ctx context.Context, arg SearchAllFilesByOwnerParams) ([]SearchAllFilesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, searchAllFilesByOwner, arg.OwnerID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchAllFilesByOwnerRow
	for rows.Next() {
		var i SearchAllFilesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.UploadDate,
			&i.SizeBytes,
			&i.MimeType,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.FolderID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
