// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const canAccessFile = `-- name: CanAccessFile :one
SELECT EXISTS (
    SELECT 1
    FROM shares s
    WHERE s.file_id = $1
      AND (
        (s.share_type = 'public' AND s.public_token = $2)
        OR
        (s.share_type = 'user' AND s.shared_with_user_id = $3)
      )
    
    UNION
    
    SELECT 1
    FROM shares s
    JOIN folders sf ON sf.id = s.folder_id
    JOIN files f ON f.id = $1
    JOIN folders ff ON ff.id = f.folder_id
    WHERE ff.path <@ sf.path
      AND (
        (s.share_type = 'public' AND s.public_token = $2)
        OR
        (s.share_type = 'user' AND s.shared_with_user_id = $3)
      )
)
`

type CanAccessFileParams struct {
	FileID           pgtype.UUID `json:"file_id"`
	PublicToken      pgtype.Text `json:"public_token"`
	SharedWithUserID pgtype.UUID `json:"shared_with_user_id"`
}

func (q *Queries) CanAccessFile(ctx context.Context, arg CanAccessFileParams) (bool, error) {
	row := q.db.QueryRow(ctx, canAccessFile, arg.FileID, arg.PublicToken, arg.SharedWithUserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkFileOwnership = `-- name: CheckFileOwnership :one
SELECT EXISTS (
    SELECT 1 FROM files WHERE id = $1 AND owner_id = $2
)
`

type CheckFileOwnershipParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) CheckFileOwnership(ctx context.Context, arg CheckFileOwnershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkFileOwnership, arg.ID, arg.OwnerID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFileReference = `-- name: CreateFileReference :one
INSERT INTO files (owner_id, physical_file_id, folder_id, filename)
VALUES ($1, $2, $3, $4)
RETURNING id, owner_id, physical_file_id, folder_id, filename, upload_date, download_count
`

type CreateFileReferenceParams struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	PhysicalFileID pgtype.UUID `json:"physical_file_id"`
	FolderID       pgtype.UUID `json:"folder_id"`
	Filename       string      `json:"filename"`
}

func (q *Queries) CreateFileReference(ctx context.Context, arg CreateFileReferenceParams) (File, error) {
	row := q.db.QueryRow(ctx, createFileReference,
		arg.OwnerID,
		arg.PhysicalFileID,
		arg.FolderID,
		arg.Filename,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.FolderID,
		&i.Filename,
		&i.UploadDate,
		&i.DownloadCount,
	)
	return i, err
}

const createPhysicalFile = `-- name: CreatePhysicalFile :one
INSERT INTO physical_files (content_hash, mime_type, size_bytes, storage_path, reference_count)
VALUES ($1, $2, $3, $4, 1)
RETURNING id, content_hash, mime_type, size_bytes, storage_path, reference_count, created_at
`

type CreatePhysicalFileParams struct {
	ContentHash string `json:"content_hash"`
	MimeType    string `json:"mime_type"`
	SizeBytes   int64  `json:"size_bytes"`
	StoragePath string `json:"storage_path"`
}

func (q *Queries) CreatePhysicalFile(ctx context.Context, arg CreatePhysicalFileParams) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, createPhysicalFile,
		arg.ContentHash,
		arg.MimeType,
		arg.SizeBytes,
		arg.StoragePath,
	)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.ContentHash,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const decrementPhysicalFileReferenceCount = `-- name: DecrementPhysicalFileReferenceCount :exec
UPDATE physical_files SET reference_count = reference_count - 1 WHERE id = $1
`

func (q *Queries) DecrementPhysicalFileReferenceCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, decrementPhysicalFileReferenceCount, id)
	return err
}

const deleteFileReference = `-- name: DeleteFileReference :exec
DELETE FROM files WHERE id = $1
`

func (q *Queries) DeleteFileReference(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteFileReference, id)
	return err
}

const getFileById = `-- name: GetFileById :one
SELECT
    f.owner_id, f.id, f.filename, f.upload_date,
    pf.mime_type, pf.size_bytes
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE f.id = $1
`

type GetFileByIdRow struct {
	OwnerID    pgtype.UUID        `json:"owner_id"`
	ID         pgtype.UUID        `json:"id"`
	Filename   string             `json:"filename"`
	UploadDate pgtype.Timestamptz `json:"upload_date"`
	MimeType   string             `json:"mime_type"`
	SizeBytes  int64              `json:"size_bytes"`
}

func (q *Queries) GetFileById(ctx context.Context, id pgtype.UUID) (GetFileByIdRow, error) {
	row := q.db.QueryRow(ctx, getFileById, id)
	var i GetFileByIdRow
	err := row.Scan(
		&i.OwnerID,
		&i.ID,
		&i.Filename,
		&i.UploadDate,
		&i.MimeType,
		&i.SizeBytes,
	)
	return i, err
}

const getFileByIdAndOwner = `-- name: GetFileByIdAndOwner :one
SELECT id, owner_id, physical_file_id, folder_id, filename, upload_date, download_count FROM files WHERE id = $1
AND owner_id = $2
`

type GetFileByIdAndOwnerParams struct {
	ID      pgtype.UUID `json:"id"`
	OwnerID pgtype.UUID `json:"owner_id"`
}

func (q *Queries) GetFileByIdAndOwner(ctx context.Context, arg GetFileByIdAndOwnerParams) (File, error) {
	row := q.db.QueryRow(ctx, getFileByIdAndOwner, arg.ID, arg.OwnerID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.FolderID,
		&i.Filename,
		&i.UploadDate,
		&i.DownloadCount,
	)
	return i, err
}

const getFileForDeletion = `-- name: GetFileForDeletion :one
SELECT owner_id, physical_file_id FROM files WHERE id = $1
`

type GetFileForDeletionRow struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	PhysicalFileID pgtype.UUID `json:"physical_file_id"`
}

func (q *Queries) GetFileForDeletion(ctx context.Context, id pgtype.UUID) (GetFileForDeletionRow, error) {
	row := q.db.QueryRow(ctx, getFileForDeletion, id)
	var i GetFileForDeletionRow
	err := row.Scan(&i.OwnerID, &i.PhysicalFileID)
	return i, err
}

const getFileForDownload = `-- name: GetFileForDownload :one
SELECT
    f.owner_id,
    f.filename,
    pf.content_hash
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE f.id = $1
`

type GetFileForDownloadRow struct {
	OwnerID     pgtype.UUID `json:"owner_id"`
	Filename    string      `json:"filename"`
	ContentHash string      `json:"content_hash"`
}

func (q *Queries) GetFileForDownload(ctx context.Context, id pgtype.UUID) (GetFileForDownloadRow, error) {
	row := q.db.QueryRow(ctx, getFileForDownload, id)
	var i GetFileForDownloadRow
	err := row.Scan(&i.OwnerID, &i.Filename, &i.ContentHash)
	return i, err
}

const getPhysicalFileByHash = `-- name: GetPhysicalFileByHash :one
SELECT id, content_hash, mime_type, size_bytes, storage_path, reference_count, created_at FROM physical_files
WHERE content_hash = $1 LIMIT 1
`

func (q *Queries) GetPhysicalFileByHash(ctx context.Context, contentHash string) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, getPhysicalFileByHash, contentHash)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.ContentHash,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const incrementFileDownloadCount = `-- name: IncrementFileDownloadCount :exec
UPDATE files SET download_count = download_count + 1 WHERE id = $1
`

func (q *Queries) IncrementFileDownloadCount(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, incrementFileDownloadCount, id)
	return err
}

const listFilesByFolder = `-- name: ListFilesByFolder :many
SELECT
    f.id, f.filename, f.upload_date,
    pf.mime_type, pf.size_bytes
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE f.folder_id = $1
ORDER BY f.filename
`

type ListFilesByFolderRow struct {
	ID         pgtype.UUID        `json:"id"`
	Filename   string             `json:"filename"`
	UploadDate pgtype.Timestamptz `json:"upload_date"`
	MimeType   string             `json:"mime_type"`
	SizeBytes  int64              `json:"size_bytes"`
}

func (q *Queries) ListFilesByFolder(ctx context.Context, folderID pgtype.UUID) ([]ListFilesByFolderRow, error) {
	rows, err := q.db.Query(ctx, listFilesByFolder, folderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFilesByFolderRow
	for rows.Next() {
		var i ListFilesByFolderRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.UploadDate,
			&i.MimeType,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRootFilesByOwner = `-- name: ListRootFilesByOwner :many
SELECT
    f.id, f.filename, f.upload_date,
    pf.mime_type, pf.size_bytes
FROM files f
JOIN physical_files pf ON f.physical_file_id = pf.id
WHERE f.owner_id = $1 AND f.folder_id IS NULL
ORDER BY f.filename
`

type ListRootFilesByOwnerRow struct {
	ID         pgtype.UUID        `json:"id"`
	Filename   string             `json:"filename"`
	UploadDate pgtype.Timestamptz `json:"upload_date"`
	MimeType   string             `json:"mime_type"`
	SizeBytes  int64              `json:"size_bytes"`
}

func (q *Queries) ListRootFilesByOwner(ctx context.Context, ownerID pgtype.UUID) ([]ListRootFilesByOwnerRow, error) {
	rows, err := q.db.Query(ctx, listRootFilesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRootFilesByOwnerRow
	for rows.Next() {
		var i ListRootFilesByOwnerRow
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.UploadDate,
			&i.MimeType,
			&i.SizeBytes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
