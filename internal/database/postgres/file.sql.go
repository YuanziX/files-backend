// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: file.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFileReference = `-- name: CreateFileReference :one
INSERT INTO files (owner_id, physical_file_id, filename)
VALUES ($1, $2, $3)
RETURNING id, owner_id, physical_file_id, folder_id, filename, tags, upload_date
`

type CreateFileReferenceParams struct {
	OwnerID        pgtype.UUID `json:"owner_id"`
	PhysicalFileID pgtype.UUID `json:"physical_file_id"`
	Filename       string      `json:"filename"`
}

func (q *Queries) CreateFileReference(ctx context.Context, arg CreateFileReferenceParams) (File, error) {
	row := q.db.QueryRow(ctx, createFileReference, arg.OwnerID, arg.PhysicalFileID, arg.Filename)
	var i File
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.PhysicalFileID,
		&i.FolderID,
		&i.Filename,
		&i.Tags,
		&i.UploadDate,
	)
	return i, err
}

const createPhysicalFile = `-- name: CreatePhysicalFile :one
INSERT INTO physical_files (content_hash, mime_type, size_bytes, storage_path, reference_count)
VALUES ($1, $2, $3, $4, 1)
RETURNING id, content_hash, mime_type, size_bytes, storage_path, reference_count, created_at
`

type CreatePhysicalFileParams struct {
	ContentHash string `json:"content_hash"`
	MimeType    string `json:"mime_type"`
	SizeBytes   int64  `json:"size_bytes"`
	StoragePath string `json:"storage_path"`
}

func (q *Queries) CreatePhysicalFile(ctx context.Context, arg CreatePhysicalFileParams) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, createPhysicalFile,
		arg.ContentHash,
		arg.MimeType,
		arg.SizeBytes,
		arg.StoragePath,
	)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.ContentHash,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const getPhysicalFileByHash = `-- name: GetPhysicalFileByHash :one
SELECT id, content_hash, mime_type, size_bytes, storage_path, reference_count, created_at FROM physical_files
WHERE content_hash = $1 LIMIT 1
`

func (q *Queries) GetPhysicalFileByHash(ctx context.Context, contentHash string) (PhysicalFile, error) {
	row := q.db.QueryRow(ctx, getPhysicalFileByHash, contentHash)
	var i PhysicalFile
	err := row.Scan(
		&i.ID,
		&i.ContentHash,
		&i.MimeType,
		&i.SizeBytes,
		&i.StoragePath,
		&i.ReferenceCount,
		&i.CreatedAt,
	)
	return i, err
}

const listFilesByOwner = `-- name: ListFilesByOwner :many
SELECT id, owner_id, physical_file_id, folder_id, filename, tags, upload_date FROM files
WHERE owner_id = $1
ORDER BY upload_date DESC
`

func (q *Queries) ListFilesByOwner(ctx context.Context, ownerID pgtype.UUID) ([]File, error) {
	rows, err := q.db.Query(ctx, listFilesByOwner, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []File
	for rows.Next() {
		var i File
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.PhysicalFileID,
			&i.FolderID,
			&i.Filename,
			&i.Tags,
			&i.UploadDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
